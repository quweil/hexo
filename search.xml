<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis学习笔记之缓存穿透、击穿、雪崩、预热、更新、降级</title>
      <link href="/2022/10/25/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E9%A2%84%E7%83%AD%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E9%99%8D%E7%BA%A7-20221025/"/>
      <url>/2022/10/25/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E9%A2%84%E7%83%AD%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E9%99%8D%E7%BA%A7-20221025/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-缓存穿透"><a href="#Redis-缓存穿透" class="headerlink" title="Redis-缓存穿透"></a>Redis-缓存穿透</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p>当然，使用缓存难免会有穿透的发生。</p><ul><li>缓存容量有限，不可能去缓存所有数据，查询到未被缓存的数据就会发生穿透是正常情况。</li><li>互联网业务的数据访问模型一般是遵循二八原则的，即 20% 的数据为热点数据，80% 的数据是非热点不被常访问的数据。既然缓存容量有限，且20%的数据为热点数据，那我们可以利用有限的容量去缓存那 20% 的数据来保护我们的系统，至于80%非热点不常用的数据发生穿透就穿透了，数据库吃得住</li></ul><h3 id="怎么解决缓存穿透"><a href="#怎么解决缓存穿透" class="headerlink" title="怎么解决缓存穿透"></a>怎么解决缓存穿透</h3><p>解决缓存穿透的方法有很多，在这里就列举几个</p><ol><li><p>接口参数校验<br>在参数校验层加上参数合法性校验，如查询订单ID为20位随机值，正则核对一下ID长度是否规范，不规范地直接过滤掉。</p></li><li><p>设置空值<br>当访问缓存和DB都没有查询到值时，该key我们当做是恶意参数来看，可以将该key的空值写进缓存，设置较短的过期时间。<br>但是如果有大量的获取并不存在数据的穿透请求的话如恶意攻击，则会浪费缓存空间，如果这种null值过量的话，还会淘汰掉本身缓存存在的数据，这就会使我们的缓存命中率下降。<br>因此在使用设置空值方案时，我们要做好监控，预防缓存空间被过多null值占领造成的缓存空间浪费，如果这种数据量太大，就不再建议使用，那就使用另一种方案，即布隆过滤器。</p></li><li><p>布隆过滤器<br>布隆过滤器在查询缓存之前起到初步过滤作用，布隆过滤器存储所有可能访问的 key，将不存在的 key 直接过滤，存在的 key 再进一步查询缓存和数据库。<br>布隆过滤器的特点是判断不存在的，则一定不存在；判断存在的，大概率存在，但也有小概率不存在。并且这个概率是可控的，根据具体需求，我们可以让这个概率小幅降低或变高。<br><img src="/upload/2022/10/image-1666581138787.png" alt="image-1666581138787"><br>布隆过滤器由一个 bitSet 和 一组 Hash 函数（算法）组成，是一种空间效率极高的概率型算法和数据结构，通过二进制来进行数据存储。在初始化时，bitSet 的每一位被初始化为0。<br>当数据加入布隆过滤器集合时，流程如下：<br><img src="/upload/2022/10/image-1666581156358.png" alt="image-1666581156358"></p></li></ol><ul><li>经过K个哈希函数计算该数据，返回K个计算出的hash值</li><li>这些K个hash值映射到对应的K个二进制的数组下标</li><li>将K个下标对应的二进制数据改为1。<br>布隆过滤器查询一个key是否在集合中，流程如下：</li><li>经过K个哈希函数计算该数据，对应计算出的K个hash值</li><li>经过hash值找到对应的二进制的数组下标</li><li>如果存在其中一处位置的二进制数据是0，那么该数据不存在。若是都是1，该数据存在集合中（但由于存在Hash碰撞，判断数据存在时可能存在误判）。<br><strong>布隆过滤器的优缺点</strong><br>优势</li><li>因为存储的是二进制数据，因此占用的空间很小；</li><li>它的插入和查询速度是很是快的，时间复杂度是O（K），能够联想一下HashMap的过程；</li><li>保密性很好，由于自己不存储任何原始数据，只有二进制数据<br>缺点</li><li>存在误判<br>添加数据是经过计算数据的hash值，hash是存在碰撞的，也就是说，存在两个不一样的数据计算获得相同的hash值。<br><img src="/upload/2022/10/image-1666581505755.png" alt="image-1666581505755"><br>例如图中的你好和hello，假如最终算出hash值相同，那么他们会将同一个下标的二进制数据改成1。因此也无法确定key为你好和hello是否存在。</li><li>删除困难<br>如上，你好和hello的hash值相同，对应的数组下标也是同样的。如果想删除你好，即将坐标值改为0，可能会影响到其他key，比如是否会连hello都一块儿删了之类的。</li></ul><h2 id="Redis-缓存击穿"><a href="#Redis-缓存击穿" class="headerlink" title="Redis-缓存击穿"></a>Redis-缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>缓存击穿：指缓存中没有但数据库中有的数据（一般是热点数据缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去查，引起数据库压力瞬间增大，线上系统卡住。</p><h3 id="怎么解决缓存击穿"><a href="#怎么解决缓存击穿" class="headerlink" title="怎么解决缓存击穿"></a>怎么解决缓存击穿</h3><ol><li>加互斥锁<br>在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。<blockquote><p>互斥锁</p><p>缓存击穿后，多个线程会同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。</p><p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">reenLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getData04</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 从缓存读取数据</span></span><br><span class="line">        result = getDataFromCache();</span><br><span class="line">        <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reenLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;拿到锁了,从DB获取数据库后写入缓存&quot;</span>);</span><br><span class="line">                    <span class="comment">// 从数据库查询数据</span></span><br><span class="line">                    result = getDataFromDB();</span><br><span class="line">                    <span class="comment">// 将查询到的数据写入缓存</span></span><br><span class="line">                    setDataToCache(result);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    reenLock.unlock();<span class="comment">// 释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = getDataFromCache();<span class="comment">// 先查一下缓存</span></span><br><span class="line">                <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我没拿到锁,缓存也没数据,先小憩一下&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);<span class="comment">// 小憩一会儿</span></span><br><span class="line">                    <span class="keyword">return</span> getData04();<span class="comment">// 重试</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>热点数据不过期<br>根据实际业务情况，在Redis中维护一个热点数据表，批量设为永不过期（如top1000），并定时更新top1000数据。<br>这种方式适用于比较极端的场景，例如流量特别特别大的场景，使用时需要考虑业务能接受数据不一致的时间，还有就是异常情况的处理，不要到时候缓存刷新不上，一直是脏数据，那就凉了。</li></ol><h2 id="Redis-缓存雪崩"><a href="#Redis-缓存雪崩" class="headerlink" title="Redis-缓存雪崩"></a>Redis-缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>缓存雪崩：大量的热点 key 设置了相同的过期时间，导致缓存在同一时刻全部失效，造成瞬时数据库请求量大、压力骤增，引起雪崩，甚至导致数据库被打挂。缓存雪崩其实有点像升级版的缓存击穿，缓存击穿是一个热点 key，缓存雪崩是一组热点 key。</p><h3 id="怎么解决缓存雪崩"><a href="#怎么解决缓存雪崩" class="headerlink" title="怎么解决缓存雪崩"></a>怎么解决缓存雪崩</h3><ol><li>过期时间打散<br>既然是大量缓存集中失效，那最容易想到就是让他们不集中生效。可以给缓存的过期时间加上一个随机值时间，使得每个 key 的过期时间分布开来，不会集中在同一时刻失效。</li><li>热点数据不过期<br>缓存永不过期，异步更新缓存数据。虽然不会出现雪崩效应，却无法保证数据的一致性。</li><li>加互斥锁<br>jvm锁机制、分布式锁机制都可以。该方式和缓存击穿一样，按 key 维度加锁，对于同一个 key，只允许一个线程去计算，其他线程原地阻塞等待第一个线程的计算结果，然后直接走缓存即可。</li></ol><h2 id="Redis-缓存预热"><a href="#Redis-缓存预热" class="headerlink" title="Redis-缓存预热"></a>Redis-缓存预热</h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h2 id="Redis-缓存更新"><a href="#Redis-缓存更新" class="headerlink" title="Redis-缓存更新"></a>Redis-缓存更新</h2><p>缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>（1）定时去清理过期的缓存；<br>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><h2 id="Redis-缓存降级"><a href="#Redis-缓存降级" class="headerlink" title="Redis-缓存降级"></a>Redis-缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）</p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Redis基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springcloud入门</title>
      <link href="/2022/10/17/Springcloud%E5%85%A5%E9%97%A8-20221018/"/>
      <url>/2022/10/17/Springcloud%E5%85%A5%E9%97%A8-20221018/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cloud是什么"><a href="#Spring-Cloud是什么" class="headerlink" title="Spring Cloud是什么"></a>Spring Cloud是什么</h2><p>Spring Cloud 是一款基于 Spring Boot 实现的微服务框架。Spring Cloud 源自 Spring 社区，主要由 Pivotal 和 Netflix 两大公司提供技术迭代和维护。</p><p>随着微服务的火爆流行，国内外各大互联网公司都相继分享了他们在微服务架构中，针对不同场景出现的各种问题的解决方案和开源框架。</p><ul><li><strong>服务治理</strong>：阿里巴巴开源的 Dubbo 和当当网在其基础上扩展出来的 DubboX、Netflix 的 Eureka 以及 Apache 的 Consul 等。</li><li><strong>分布式配置管理</strong>：百度的 Disconf、Netflix 的 Archaius、360 的 QConf、携程的 Apollo 以及 Spring Cloud 的 Config 等。</li><li><strong>批量任务</strong>：当当网的 Elastic-Job、LinkedIn 的 Azkaban 以及 Spring Cloud 的 Task 等。</li><li><strong>服务跟踪</strong>：京东的 Hydra、Spring Cloud 的 Sleuth 以及 Twitter 的 Zipkin 等。</li><li>……</li></ul><p>以上这些微服务框架或解决方案都具有以下 2 个特点：</p><ul><li>对于同一个微服务问题，各互联网公司给出的解决方案各不相同。</li><li>一个微服务框架或解决方案都只能解决微服务中的某一个或某几个问题，对于其他问题则无能为力。</li></ul><p>这种情况下，搭建一套微分布式微服务系统，就需要针对这些问题从诸多的解决方案中做出选择，这使得我们不得不将大量的精力花费在前期的调研、分析以及实验上。</p><p>Spring Cloud 被称为构建分布式微服务系统的“全家桶”，它并不是某一门技术，而是一系列微服务解决方案或框架的有序集合。它将市面上成熟的、经过验证的微服务框架整合起来，并通过 Spring Boot 的思想进行再封装，屏蔽调其中复杂的配置和实现原理，最终为开发人员提供了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>Spring Cloud 中包含了 spring-cloud-config、spring-cloud-bus 等近 20 个子项目，提供了服务治理、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列、配置管理等领域的解决方案。</p><p>Spring Cloud 并不是一个拿来即可用的框架，它是一种微服务规范，共有以下 2 代实现：</p><ul><li>第一代实现：Spring Cloud Netflix </li><li><img src="/upload/2022/10/image-1665997277161.png" alt="image-1665997277161"></li><li>第二代实现：Spring Cloud Alibaba </li><li><img src="/upload/2022/10/image-1665997197278.png" alt="image-1665997197278"></li></ul><h2 id="Spring-Boot-和-Spring-Cloud-的区别与联系"><a href="#Spring-Boot-和-Spring-Cloud-的区别与联系" class="headerlink" title="Spring Boot 和 Spring Cloud 的区别与联系"></a>Spring Boot 和 Spring Cloud 的区别与联系</h2><p>Spring Boot 和 Spring Cloud 都是 Spring 大家族的一员，它们在微服务开发中都扮演着十分重要的角色，两者之间既存在区别也存在联系。</p><ol><li>Spring Boot 和 Spring Cloud 分工不同<br>Spring Boot 是一个基于 Spring 的快速开发框架，它能够帮助开发者迅速搭 Web 工程。在微服务开发中，Spring Boot 专注于快速、方便地开发单个微服务。</li></ol><p>Spring Cloud 是微服务架构下的一站式解决方案。Spring Cloud 专注于全局微服务的协调和治理工作。换句话说，Spring Cloud 相当于微服务的大管家，负责将 Spring Boot 开发的一个个微服务管理起来，并为它们提供配置管理、服务发现、断路器、路由、微代理、事件总线、决策竞选以及分布式会话等服务。<br>2. Spring Cloud 是基于 Spring Boot 实现的<br>Spring Cloud 是基于 Spring Boot 实现的。与 Spring Boot 类似，Spring Cloud 也为提供了一系列 Starter，这些 Starter 是 Spring Cloud 使用 Spring Boot 思想对各个微服务框架进行再封装的产物。它们屏蔽了这些微服务框架中复杂的配置和实现原理，使开发人员能够快速、方便地使用 Spring Cloud 搭建一套分布式微服务系统。<br>3. Spring Boot 和 Spring Cloud 依赖项数量不同<br>Spring Boot 属于一种轻量级的框架，构建 Spring Boot 工程所需的依赖较少。</p><p>Spring Cloud 是一系列微服务框架技术的集合体，它的每个组件都需要一个独立的依赖项（Starter POM），因此想要构建一套完整的 Spring  Cloud 工程往往需要大量的依赖项。<br>4. Spring Cloud 不能脱离 Spring Boot 单独运行<br>Spring Boot 不需要 Spring Cloud，就能直接创建可独立运行的工程或模块。</p><p>Spring Cloud 是基于 Spring Boot 实现的，它不能独立创建工程或模块，更不能脱离 Spring Boot 独立运行。<br>注意：虽然 Spring Boot 能够用于开发单个微服务，但它并不具备管理和协调微服务的能力，因此它只能算是一个微服务快速开发框架，而非微服务框架。</p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> springcloud基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础之函数补充（MySQL版）</title>
      <link href="/2022/10/12/SQL%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85%EF%BC%88MySQL%E7%89%88%EF%BC%89-20221011/"/>
      <url>/2022/10/12/SQL%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85%EF%BC%88MySQL%E7%89%88%EF%BC%89-20221011/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL基础之函数补充（MySQL版）"><a href="#SQL基础之函数补充（MySQL版）" class="headerlink" title="SQL基础之函数补充（MySQL版）"></a>SQL基础之函数补充（MySQL版）</h2><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><pre><code>**数学函数主要用于处理数字，包括整型、浮点数等。</code></pre><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回x的绝对值 不区分大小写</td></tr><tr><td>CEIL(x),CEILING(x)</td><td>返回大于或等于x的最小整数</td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于x的最大整数</td></tr><tr><td>RAND()</td><td>返回0-&gt;1的随机数</td></tr><tr><td>RAND(x)</td><td>返回0-&gt;1的随机数，x值相同时返回的随机数相同</td></tr><tr><td>PI()</td><td>返回圆周率(3.141593）</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数值x保留到小数点后y位的值（与ROUND最大的区别是不会进行四舍五入）</td></tr><tr><td>ROUND(x,y)</td><td>保留x小数点后y位的值，但截断时要进行四舍五入</td></tr><tr><td>POW(x,y).POWER(x,y)</td><td>返回x的y次方</td></tr><tr><td>SQRT(x)</td><td>返回x的平方根</td></tr><tr><td>EXP(x)</td><td>返回e的x次方</td></tr><tr><td>MOD(x,y)</td><td>返回x除以y以后的余数</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**ABS(x)**</span><br><span class="line">返回x的绝对值　　不区分大小写</span><br><span class="line"></span><br><span class="line">**SELECT ABS(-1)** -- 返回1</span><br><span class="line"></span><br><span class="line">**CEIL(x),CEILING(x)**</span><br><span class="line">返回大于或等于x的最小整数　　</span><br><span class="line"></span><br><span class="line">**SELECT CEIL(1.5)** -- 返回2</span><br><span class="line"></span><br><span class="line">**FLOOR(x)**</span><br><span class="line">返回小于或等于x的最大整数　　</span><br><span class="line"></span><br><span class="line">**SELECT FLOOR(1.5)** -- 返回1</span><br><span class="line"></span><br><span class="line">**RAND()**</span><br><span class="line">返回0-&gt;1的随机数　　</span><br><span class="line"></span><br><span class="line">**SELECT RAND() --0.93099315644334**</span><br><span class="line"></span><br><span class="line">**RAND(x)**</span><br><span class="line">返回0-&gt;1的随机数，x值相同时返回的随机数相同　　</span><br><span class="line"></span><br><span class="line">**SELECT RAND(2) --1.5865798029924**</span><br><span class="line"></span><br><span class="line">**PI()**</span><br><span class="line">返回圆周率(3.141593）　　</span><br><span class="line"></span><br><span class="line">**SELECT PI() --3.141593**</span><br><span class="line"></span><br><span class="line">**TRUNCATE(x,y)**</span><br><span class="line">返回数值x保留到小数点后y位的值（与ROUND最大的区别是不会进行四舍五入）　　</span><br><span class="line"></span><br><span class="line">**SELECT TRUNCATE(1.23456,3) -- 1.234**</span><br><span class="line"></span><br><span class="line">**ROUND(x,y)**</span><br><span class="line">保留x小数点后y位的值，但截断时要进行四舍五入　　</span><br><span class="line"></span><br><span class="line">**SELECT ROUND(1.23456,3) -- 1.235**</span><br><span class="line"></span><br><span class="line">**POW(x,y).POWER(x,y)**</span><br><span class="line">返回x的y次方　　</span><br><span class="line"></span><br><span class="line">**SELECT POW(2,3) -- 8**</span><br><span class="line"></span><br><span class="line">**SQRT(x)**</span><br><span class="line">返回x的平方根　　</span><br><span class="line"></span><br><span class="line">**SELECT SQRT(25) -- 5**</span><br><span class="line"></span><br><span class="line">**EXP(x)**</span><br><span class="line">返回e的x次方　　</span><br><span class="line"></span><br><span class="line">**SELECT EXP(3) -- 20.085536923188**</span><br><span class="line"></span><br><span class="line">**MOD(x,y)**</span><br><span class="line">返回x除以y以后的余数　　</span><br><span class="line"></span><br><span class="line">**SELECT MOD(5,2) -- 1**</span><br></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><pre><code>**字符串函数是MySQL中最常用的一类函数，字符串函数主要用于处理表中的字符串。</code></pre><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>CHAR_LENGTH(s)</td><td>返回字符串s的字符数</td></tr><tr><td>CONCAT(s1,s2,…)</td><td>将字符串s1,s2等多个字符串合并为一个字符串</td></tr><tr><td>CONCAT_WS(x,s1,s2,…)</td><td>同CONCAT(s1,s2,…)函数，但是每个字符串直接要加上x</td></tr><tr><td>INSERT(s1,x,len,s2)将字符串s2替换s1的x位置开始长度为len的字符串 x从1开始</td><td>将字符串s2替换s1的x位置开始长度为len的字符串 x从1开始</td></tr><tr><td>UPPER(s),UCAASE(S)</td><td>将字符串s的所有字母变成大写字母</td></tr><tr><td>LOWER(s),LCASE(s)</td><td>将字符串s的所有字母变成小写字母</td></tr><tr><td>LEFT(s,n)</td><td>返回字符串s的前n个字符</td></tr><tr><td>RIGHT(s,n)</td><td>返回字符串s的后n个字符</td></tr><tr><td>LTRIM(s)</td><td>去掉字符串s开始处的空格</td></tr><tr><td>RTRIM(s)</td><td>去掉字符串s结尾处的空格</td></tr><tr><td>TRIM(s)</td><td>去掉字符串s开始和结尾处的空格</td></tr><tr><td>REPEAT(s,n)</td><td>将字符串s重复n次</td></tr><tr><td>SPACE(n)</td><td>返回n个空格</td></tr><tr><td>REPLACE(s,s1,s2)</td><td>将字符串s2替代字符串s中的字符串s1</td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串s1和s2</td></tr><tr><td>SUBSTRING(s,n,len)</td><td>获取从字符串s中的第n个位置开始长度为len的字符串</td></tr><tr><td>LOCATE(s1,s),POSITION(s1 IN s)</td><td>从字符串s中获取s1的开始位置</td></tr><tr><td>REVERSE(s)</td><td>将字符串s的顺序反过来</td></tr><tr><td>FIELD(s,s1,s2…)</td><td>返回第一个与字符串s匹配的字符串位置</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**CHAR_LENGTH(s)**</span><br><span class="line">返回字符串s的字符数</span><br><span class="line"></span><br><span class="line">**SELECT CHAR_LENGTH(&#x27;你好123&#x27;) -- 5**</span><br><span class="line"></span><br><span class="line">**CONCAT(s1,s2,...)**</span><br><span class="line">将字符串s1,s2等多个字符串合并为一个字符串</span><br><span class="line"></span><br><span class="line">**SELECT CONCAT(&#x27;12&#x27;,&#x27;34&#x27;) -- 1234**</span><br><span class="line"></span><br><span class="line">**CONCAT_WS(x,s1,s2,...)**</span><br><span class="line">同CONCAT(s1,s2,...)函数，但是每个字符串直接要加上x</span><br><span class="line"></span><br><span class="line">**SELECT CONCAT_WS(&#x27;@&#x27;,&#x27;12&#x27;,&#x27;34&#x27;) -- 12@34**</span><br><span class="line"></span><br><span class="line">**INSERT(s1,x,len,s2)**</span><br><span class="line">将字符串s2替换s1的x位置开始长度为len的字符串 x从1开始</span><br><span class="line"></span><br><span class="line">**SELECT INSERT(&#x27;12345&#x27;,1,3,&#x27;abc&#x27;) -- abc45**</span><br><span class="line"></span><br><span class="line">**UPPER(s),UCAASE(S)**</span><br><span class="line">将字符串s的所有字母变成大写字母</span><br><span class="line"></span><br><span class="line">**SELECT UPPER(&#x27;abc&#x27;) -- ABC**</span><br><span class="line"></span><br><span class="line">**LOWER(s),LCASE(s)**</span><br><span class="line">将字符串s的所有字母变成小写字母</span><br><span class="line"></span><br><span class="line">**SELECT LOWER(&#x27;ABC&#x27;) -- abc**</span><br><span class="line"></span><br><span class="line">**LEFT(s,n)**</span><br><span class="line">返回字符串s的前n个字符</span><br><span class="line"></span><br><span class="line">**SELECT LEFT(&#x27;abcde&#x27;,2) -- ab**</span><br><span class="line"></span><br><span class="line">**RIGHT(s,n)**</span><br><span class="line">返回字符串s的后n个字符</span><br><span class="line"></span><br><span class="line">**SELECT RIGHT(&#x27;abcde&#x27;,2) -- de**</span><br><span class="line"></span><br><span class="line">**LTRIM(s)** 去掉字符串s开始处的空格</span><br><span class="line">**RTRIM(s)** 去掉字符串s结尾处的空格</span><br><span class="line">**TRIM(s)** 去掉字符串s开始和结尾处的空格</span><br><span class="line">**SELECT TRIM(&#x27;@&#x27; FROM &#x27;@@abc@@&#x27;) -- abc**</span><br><span class="line"></span><br><span class="line">**REPEAT(s,n)**</span><br><span class="line">将字符串s重复n次</span><br><span class="line"></span><br><span class="line">**SELECT REPEAT(&#x27;ab&#x27;,3) -- ababab**</span><br><span class="line"></span><br><span class="line">**SPACE(n)** 返回n个空格</span><br><span class="line"></span><br><span class="line">**REPLACE(s,s1,s2)**</span><br><span class="line">将字符串s2替代字符串s中的字符串s1</span><br><span class="line"></span><br><span class="line">**SELECT REPLACE(&#x27;abca&#x27;,&#x27;a&#x27;,&#x27;x&#x27;) --xbcx**</span><br><span class="line"></span><br><span class="line">**STRCMP(s1,s2)** 比较字符串s1和s2</span><br><span class="line"></span><br><span class="line">**SUBSTRING(s,n,len)** 获取从字符串s中的第n个位置开始长度为len的字符串</span><br><span class="line"></span><br><span class="line">**LOCATE(s1,s),POSITION(s1 IN s)**</span><br><span class="line">从字符串s中获取s1的开始位置</span><br><span class="line"></span><br><span class="line">**SELECT LOCATE(&#x27;b&#x27;, &#x27;abc&#x27;) -- 2**</span><br><span class="line"></span><br><span class="line">**REVERSE(s)**</span><br><span class="line">将字符串s的顺序反过来</span><br><span class="line"></span><br><span class="line">**SELECT REVERSE(&#x27;abc&#x27;) -- cba**</span><br><span class="line"></span><br><span class="line">**FIELD(s,s1,s2...)**</span><br><span class="line">返回第一个与字符串s匹配的字符串位置</span><br><span class="line"></span><br><span class="line">**SELECT FIELD(&#x27;c&#x27;,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) -- 3**</span><br><span class="line">     </span><br><span class="line"> --replace(源字符,需要替换的字符，替换的字符)</span><br><span class="line">SELECT REPLACE(&quot;abcd        &quot;,&#x27; &#x27;,&#x27;#&#x27;)</span><br></pre></td></tr></table></figure><h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h3><pre><code>**MySQL的日期和时间函数主要用于处理日期时间。</code></pre><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>CURDATE(),CURRENT_DATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME(),CURRENT_TIME</td><td>返回当前时间</td></tr><tr><td>NOW(),CURRENT_TIMESTAMP(),LOCALTIME()，SYSDATE(),LOCALTIMESTAMP()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(d)，MONTH(d)，DAY(d)</td><td>返回日期d中的月份值，1-&gt;12</td></tr><tr><td>MONTHNAME(d)</td><td>返回日期当中的月份名称，如Janyary</td></tr><tr><td>DAYNAME(d)</td><td>返回日期d是星期几，如Monday,Tuesday</td></tr><tr><td>DAYOFWEEK(d)</td><td>日期d今天是星期几，1星期日，2星期一</td></tr><tr><td>WEEKDAY(d)</td><td>日期d今天是星期几，0表示星期一，1表示星期二</td></tr><tr><td>WEEK(d)，WEEKOFYEAR(d)</td><td>计算日期d是本年的第几个星期，范围是0-&gt;53</td></tr><tr><td>DAYOFYEAR(d)</td><td>计算日期d是本年的第几天</td></tr><tr><td>DAYOFMONTH(d)</td><td>计算日期d是本月的第几天</td></tr><tr><td>QUARTER(d)</td><td>返回日期d是第几季节，返回1-&gt;4</td></tr><tr><td>HOUR(t)</td><td>返回t中的小时值</td></tr><tr><td>MINUTE(t)</td><td>返回t中的分钟值</td></tr><tr><td>SECOND(t)</td><td>返回t中的秒钟值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">*</span><span class="operator">*</span>CURDATE(),<span class="built_in">CURRENT_DATE</span>()<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">返回当前日期</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> CURDATE()<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">2014</span><span class="number">-12</span><span class="number">-17</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>CURTIME(),<span class="built_in">CURRENT_TIME</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">返回当前时间</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> CURTIME()<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">15</span>:<span class="number">59</span>:<span class="number">02</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>NOW(),<span class="built_in">CURRENT_TIMESTAMP</span>(),<span class="built_in">LOCALTIME</span>(),<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>SYSDATE(),<span class="built_in">LOCALTIMESTAMP</span>()<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line">返回当前日期和时间</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> NOW()<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">2014</span><span class="number">-12</span><span class="number">-17</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">02</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">YEAR</span>(d),<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">MONTH</span>(d)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">DAY</span>(d)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">返回日期d中的月份值，<span class="number">1</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="string">&#x27;2011-11-11 11:11:11&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">11</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>MONTHNAME(d)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">返回日期当中的月份名称，如Janyary</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> MONTHNAME(<span class="string">&#x27;2011-11-11 11:11:11&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span>November<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>DAYNAME(d)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">返回日期d是星期几，如Monday,Tuesday</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> DAYNAME(<span class="string">&#x27;2011-11-11 11:11:11&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span>Friday<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>DAYOFWEEK(d)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">日期d今天是星期几，<span class="number">1</span>星期日，<span class="number">2</span>星期一</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> DAYOFWEEK(<span class="string">&#x27;2011-11-11 11:11:11&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">6</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>WEEKDAY(d)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">日期d今天是星期几，</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>表示星期一，<span class="number">1</span>表示星期二</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>WEEK(d)，WEEKOFYEAR(d)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">计算日期d是本年的第几个星期，范围是<span class="number">0</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> WEEK(<span class="string">&#x27;2011-11-11 11:11:11&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">45</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>DAYOFYEAR(d)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">计算日期d是本年的第几天</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> DAYOFYEAR(<span class="string">&#x27;2011-11-11 11:11:11&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">315</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line">DAYOFMONTH(d)</span><br><span class="line">计算日期d是本月的第几天</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> DAYOFMONTH(<span class="string">&#x27;2011-11-11 11:11:11&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">11</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span>QUARTER(d)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">返回日期d是第几季节，返回<span class="number">1</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> QUARTER(<span class="string">&#x27;2011-11-11 11:11:11&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">4</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">HOUR</span>(t)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">返回t中的小时值</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> <span class="keyword">HOUR</span>(<span class="string">&#x27;1:2:3&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">1</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">MINUTE</span>(t)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">返回t中的分钟值</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> <span class="keyword">MINUTE</span>(<span class="string">&#x27;1:2:3&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">2</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SECOND</span>(t)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line">返回t中的秒钟值</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="keyword">SELECT</span> <span class="keyword">SECOND</span>(<span class="string">&#x27;1:2:3&#x27;</span>)<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">3</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 数据库SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础之视图</title>
      <link href="/2022/10/11/SQL%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%A7%86%E5%9B%BE-20221010/"/>
      <url>/2022/10/11/SQL%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%A7%86%E5%9B%BE-20221010/</url>
      
        <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>​视图实际上就是一张虚拟的表，视图是针对基表的一部分字段的缩影，一般用于对一些字段比较多的表，通过视图可以简化表结构；另外针对一些涉及到多表的查询操作时，建立视图可以简化查询语句；</p><h3 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h3><p><img src="https://blog.mrquweilin.top/upload/2022/10/1596089489736.png" alt="1596089489736"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v$emp <span class="keyword">as</span> <span class="keyword">select</span> ename,job,hiredate,sal <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$emp;</span><br><span class="line"><span class="keyword">update</span> v$emp <span class="keyword">set</span> hiredate<span class="operator">=</span>now() <span class="keyword">where</span> ename<span class="operator">=</span><span class="string">&#x27;孙悟空&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复杂视图创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v$details</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">e.eno,e.ename,e.job,e.hiredate,e.age,e.sal,</span><br><span class="line">d.dno,d.dname,d.tel,</span><br><span class="line">s.level</span><br><span class="line"><span class="keyword">from</span> emp e,dept d,sallevel s <span class="keyword">where</span> e.dno<span class="operator">=</span>d.dno <span class="keyword">and</span> </span><br><span class="line">e.sal <span class="keyword">between</span> s.lowsal <span class="keyword">and</span> s.hisal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> level <span class="keyword">from</span> v$details <span class="keyword">where</span> eno<span class="operator">=</span><span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询研发部所有人的薪资等级和部门信息</span></span><br><span class="line"><span class="keyword">select</span> level,ename <span class="keyword">from</span> v$details <span class="keyword">where</span> dname<span class="operator">=</span><span class="string">&#x27;研发部&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h3><p>视图与表在本质上虽然不相同，但视图经过定义以后，结构形式和表一样，可以进行查询、修改、更新和删除等操作。同时，视图具有如下优点：</p><h4 id="1-定制用户数据，聚焦特定的数据"><a href="#1-定制用户数据，聚焦特定的数据" class="headerlink" title="1) 定制用户数据，聚焦特定的数据"></a>1) 定制用户数据，聚焦特定的数据</h4><p>在实际的应用过程中，不同的用户可能对不同的数据有不同的要求。</p><p>例如，当数据库同时存在时，如学生基本信息表、课程表和教师信息表等多种表同时存在时，可以根据需求让不同的用户使用各自的数据。学生查看修改自己基本信息的视图，安排课程人员查看修改课程表和教师信息的视图，教师查看学生信息和课程信息表的视图。</p><h4 id="2-简化数据操作"><a href="#2-简化数据操作" class="headerlink" title="2) 简化数据操作"></a>2) 简化数据操作</h4><p>在使用查询时，很多时候要使用聚合函数，同时还要显示其他字段的信息，可能还需要关联到其他表，语句可能会很长，如果这个动作频繁发生的话，可以创建视图来简化操作。</p><h4 id="3-提高数据的安全性"><a href="#3-提高数据的安全性" class="headerlink" title="3) 提高数据的安全性"></a>3) 提高数据的安全性</h4><p>视图是虚拟的，物理上是不存在的。可以只授予用户视图的权限，而不具体指定使用表的权限，来保护基础数据的安全。</p><h4 id="4-共享所需数据"><a href="#4-共享所需数据" class="headerlink" title="4) 共享所需数据"></a>4) 共享所需数据</h4><p>通过使用视图，每个用户不必都定义和存储自己所需的数据，可以共享数据库中的数据，同样的数据只需要存储一次。</p><h4 id="5-更改数据格式"><a href="#5-更改数据格式" class="headerlink" title="5) 更改数据格式"></a>5) 更改数据格式</h4><p>通过使用视图，可以重新格式化检索出的数据，并组织输出到其他应用程序中。</p><h4 id="6-重用-SQL-语句"><a href="#6-重用-SQL-语句" class="headerlink" title="6) 重用 SQL 语句"></a>6) 重用 SQL 语句</h4><p>视图提供的是对查询操作的封装，本身不包含数据，所呈现的数据是根据视图定义从基础表中检索出来的，如果基础表的数据新增或删除，视图呈现的也是更新后的数据。视图定义后，编写完所需的查询，可以方便地重用该视图。</p><p><strong>要注意区别视图和数据表的本质，即视图是基于真实表的一张虚拟的表，其数据来源均建立在真实表的基础上。</strong></p><p>使用视图的时候，还应该注意以下几点：</p><ul><li>创建视图需要足够的访问权限。</li><li>创建视图的数目没有限制。</li><li>视图可以嵌套，即从其他视图中检索数据的查询来创建视图。</li><li>视图不能索引，也不能有关联的触发器、默认值或规则。</li><li>视图可以和表一起使用。</li><li>视图不包含数据，所以每次使用视图时，都必须执行查询中所需的任何一个检索操作。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。<blockquote><p>提示：ORDER BY 子句可以用在视图中，但若该视图检索数据的 SELECT 语句中也含有 ORDER BY 子句，则该视图中的 ORDER BY 子句将被覆盖。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 数据库SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础之内置函数（MySQL版）</title>
      <link href="/2022/10/10/SQL%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%EF%BC%88MySQL%E7%89%88%EF%BC%89-20221009/"/>
      <url>/2022/10/10/SQL%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%EF%BC%88MySQL%E7%89%88%EF%BC%89-20221009/</url>
      
        <content type="html"><![CDATA[<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>count()</td><td>统计数据行</td></tr><tr><td>sum()</td><td>对指定列求和</td></tr><tr><td>avg()</td><td>对指定列求平均值</td></tr><tr><td>max()</td><td>获取指定列最大值</td></tr><tr><td>min()</td><td>获取指定列最小值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询表中一共有多少员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询所有员工的总薪资</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(sal) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询所有员工的月薪平均值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询工资最低的员工薪资</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(sal) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询工资最高的员工薪资</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(sal) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>concat (st2 [,… ])</td><td>连接多个字符串为一个字符串</td></tr><tr><td>length(s)</td><td>获取字符串的字节长度</td></tr><tr><td>lcase&#x2F;ucase</td><td>字符串转小写&#x2F;字符串转大写</td></tr><tr><td>ltrim(s)&#x2F;rtrim(s)</td><td>去除字符串左边空格&#x2F;右边空格</td></tr><tr><td>substr(s,pos,len)</td><td>将字符串s从pos开始截取len长</td></tr><tr><td>lpad&#x2F;rpad</td><td>左填充&#x2F;右填充</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取字符串使用的字符集</span></span><br><span class="line"><span class="keyword">select</span> charset(<span class="string">&#x27;helloworld&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将多个字符串连接为一个字符串</span></span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;softeem&#x27;</span>)</span><br><span class="line"><span class="comment">-- 应用</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> concat(ename,job,sex) <span class="keyword">like</span> <span class="string">&#x27;%阿%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回字符占据的字节数（中文字符占3字节(utf-8),英文字母占1个字节）</span></span><br><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;软帝softeem&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将字母转小写（toLowerCase）</span></span><br><span class="line"><span class="keyword">select</span> LCASE(<span class="string">&#x27;HELLO&#x27;</span>);</span><br><span class="line"><span class="comment">-- 转大写</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span> (<span class="string">&#x27;dsasa&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 去除字符串空格</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">TRIM</span>(<span class="string">&#x27; world &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 左填充(对指定的字符串检测，长度如果未到达目标长度，则使用指定占位符从左边开始填充)</span></span><br><span class="line"><span class="keyword">select</span> LPAD(<span class="string">&#x27;softeem&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> LPAD(ename,<span class="number">10</span>,&quot;#&quot;) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> RPAD(ename,<span class="number">10</span>,&quot;#&quot;) <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line">use mydb;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbemp;</span><br><span class="line"><span class="comment">-- 字符串截取</span></span><br><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;abdcsa&#x27;</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>abs(n)</td><td>取数值绝对值</td></tr><tr><td>round</td><td>四舍五入</td></tr><tr><td>ceiling(n)</td><td>向上取整</td></tr><tr><td>floor(n)</td><td>向下取整</td></tr><tr><td>format(n,len)</td><td>截取len位小数（四舍五入）</td></tr><tr><td>rand()</td><td>获取随机数(0-1)，取0-1之间随机的小数，无限接近于0且不会等于0，无限接近于1，且不会等于1</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数值函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 绝对值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">abs</span>(<span class="number">-100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向上、向下取整</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CEILING</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">FLOOR</span>(<span class="number">3.54</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 保留指定位小数点</span></span><br><span class="line"><span class="keyword">select</span> FORMAT(<span class="number">3.1415926</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">---随机数</span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(rand()<span class="operator">*</span><span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>now()</td><td>获取当前时间</td></tr><tr><td>current_date()</td><td>获取当前日期</td></tr><tr><td>current_time()</td><td>获取当前时间（时分秒）</td></tr><tr><td>current_timestamp()</td><td>获取当前时间戳</td></tr><tr><td>date()</td><td>获取时间的日期部分</td></tr><tr><td>day()</td><td>获取日期中的天数部分</td></tr><tr><td>datediff(t1,t2)</td><td>获取两个日期之差（天数）</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 时间日期函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 获取当前的系统时间</span></span><br><span class="line"><span class="keyword">select</span> now();</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_DATE</span>();  <span class="comment">-- 获取当前日期</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_TIME</span>();<span class="comment">-- 获取当前时间</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_TIMESTAMP</span>(); <span class="comment">-- 获取当前时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>(now());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计从出生到现在一共安全生活了多少天</span></span><br><span class="line"><span class="keyword">select</span> DATEDIFF(now(),<span class="string">&#x27;1998-07-29&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取日期中的day部分(天数)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">day</span>(now());</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> temp(today <span class="type">date</span>,msg <span class="type">varchar</span>(<span class="number">30</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp <span class="keyword">values</span>(<span class="built_in">CURRENT_DATE</span>(),<span class="string">&#x27;nothing&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 日报表中获取当天提交的日报信息</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="built_in">log</span>(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">content <span class="type">varchar</span>(<span class="number">20000</span>),</span><br><span class="line"><span class="type">time</span> <span class="type">timestamp</span> <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="built_in">log</span>(content,<span class="type">time</span>) <span class="keyword">values</span>(<span class="string">&#x27;n天前收获很多！！！&#x27;</span>,<span class="string">&#x27;2020-03-29 10:11:11&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> log <span class="keyword">where</span> <span class="type">date</span>(<span class="type">time</span>)<span class="operator">=</span><span class="type">date</span>(now()); </span><br><span class="line"><span class="comment">-- 查询所有的在29号发布的日志</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> log <span class="keyword">where</span> <span class="keyword">day</span>(<span class="type">time</span>)<span class="operator">=</span><span class="number">29</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="加密函"><a href="#加密函" class="headerlink" title="加密函"></a>加密函</h2><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>md5(s)</td><td>对字符串使用md5算法加密</td></tr><tr><td>sha(s)</td><td>对字符串使用sha加密</td></tr><tr><td>password(s)</td><td>使用sha1对字符串加密</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加密函数（非对称加密）</span></span><br><span class="line"><span class="keyword">select</span> password(<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> MD5(<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> SHA(<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"></span><br><span class="line">这三种加密方式都是不可逆，不能反推破解</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 数据库SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础之SQL语言分类</title>
      <link href="/2022/10/09/SQL%E5%9F%BA%E7%A1%80%E4%B9%8BSQL%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB-20221005/"/>
      <url>/2022/10/09/SQL%E5%9F%BA%E7%A1%80%E4%B9%8BSQL%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB-20221005/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>SQL是Structured Query Language(结构化查询语言)的缩写;sql语句是专门为数据库管理提供的通用操作语言；语法类似于英语口语，在使用它时，只需要发出“做什么”的命令“怎么做”是不用使用者考虑的。sql语句分为以下几个大类：</p><ol><li><p><strong>DDL语句（数据定义语句）</strong></p><p>数据定义语句主要应用于对数据表的结构操作：比如建表，删除表，修改表的结构等；DDL语句包含以下命令：</p><ul><li>create （新建）</li><li>drop（删除，主要删除数据库中的结构，比如表，库等） </li><li>alter（主要用已有表删除，新建，修改行）</li><li>add(添加列)</li><li>modify（修改列）</li></ul></li><li><p><strong>DML语句（数据操作语句）</strong></p><p>数据操作语句一般用于对的语句数据库表中数据进行更新操作，比如添加，删除，修改数据等，DML语句包含以下命令:</p><ul><li>insert （对表新增加数据）</li><li>update（更新表字段）</li><li>delete（删除信息）</li></ul></li><li><p><strong>DQL语句（数据查询语句）</strong></p><p>数据查询语句一般用于对数据库表中数据进行查询操作，命令主要包含：select</p></li><li><p><strong>DCL语句（数据控制语句）</strong></p><p>数据控制语句一般用于对于数据库用户的权限管理，事务管理，DCL包含以下命令:</p><ul><li>grant （权限设置）</li><li>revoke（回收权限）</li><li>commit（事务提交）</li><li>rollback（事务回滚）</li></ul></li></ol><p><strong>DML操作是可以手动控制事务的开启、提交和回滚的。DDL操作是隐性提交的，不能rollback！</strong></p><blockquote><p><strong>显式提交：</strong> 用COMMIT命令直接完成的提交为显式提交。<br><strong>隐式提交：</strong>  用SQL命令间接完成的提交为隐式提交。这些命令是：  ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，  EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。<br><strong>自动提交：</strong>  若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，  系统将自动进行提交，这就是自动提交。其格式为：  SQL&gt;SET AUTOCOMMIT ON；</p></blockquote><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><ol><li><p>创建一张数据库表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp     <span class="comment">-- 创建表，名称叫emp</span></span><br><span class="line">(</span><br><span class="line">    eno <span class="type">int</span>, <span class="comment">--创建eno列，类型是int</span></span><br><span class="line">    ename <span class="type">varchar</span>(<span class="number">30</span>), <span class="comment">--创建ename列，类型是varchar长度是30字符</span></span><br><span class="line">    job <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    sex <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span>, <span class="comment">--创建sex列，类型是char</span></span><br><span class="line">    sal <span class="keyword">double</span>,</span><br><span class="line">    birth <span class="type">date</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p><strong>关于mysql中字符长度问题：</strong></p><p>如果是utf8编码下，默认的中文字符占3个字节；如果是gbk编码，默认的中文占2个字节</p><p><strong>关于char类型和varchar类型：</strong></p><ul><li>char类型是定长字符串，类似于java中String；长度一旦定义则无法改变，并且无论数据是否够指定长度，都会占满，不够的用空格填充；char类型一般应用于长度确定的字符串类型，比如：性别，手机号，身份证号等；</li><li>varchar类型是可变长度字符串，类似java中StringBuffer；长度定义之后会根据实际填充的内容，选择占用多大空间，比较节省空间；varchar类型一般使用在长度不确定的字符串类型，比如:姓名，邮箱地址，评论信息等。</li></ul></blockquote></li></ol><p>2.显示表中所有与列等其他信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> fields <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><p>语法：</p><p><code>alter table 表名 [add/drop/modify/change/rename] 列名称</code> </p><ol><li><p>新增一个列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> hiredate <span class="type">date</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">column</span> birth;</span><br></pre></td></tr></table></figure></li><li><p>修改列的类型</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp modify sal <span class="type">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改列名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp change job  ejob <span class="type">varchar</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改表名称</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp rename <span class="keyword">to</span> tbemp;</span><br></pre></td></tr></table></figure></li></ol><h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><ol><li><p>显示表中所有的数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tbemp;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="insert语句（插入）"><a href="#insert语句（插入）" class="headerlink" title="insert语句（插入）"></a>insert语句（插入）</h4><p><strong>语法：</strong></p><p><code>insert into 表名(列名1，列名2...) values(列值1,列值2...)</code></p><ol><li><p>向表中添加数据(所有列)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbemp <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;james&#x27;</span>,<span class="string">&#x27;manager&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">8796</span>,<span class="string">&#x27;2018-01-22&#x27;</span>,<span class="number">28</span>);</span><br></pre></td></tr></table></figure></li><li><p>向某一些列插入值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbemp(eno,ename,ejob,sal) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;softeem&#x27;</span>,<span class="string">&#x27;CEO&#x27;</span>,<span class="number">1500000</span>);</span><br></pre></td></tr></table></figure></li><li><p>同时插入多条数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbemp(eno,ename) <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;来福&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;狗蛋&#x27;</span>),(<span class="number">7</span>,<span class="string">&#x27;王二狗&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>插入数据出现中文乱码时解决方案：</strong></p><p>由于安装mysql使用的是UTF8编码，但是cmd命令行中默认为GBK编码，因此在命令行中</p><p>使用中文数据是会出现乱码；解决方式只需要在打开cmd命令行时输入以下命令：</p><ul><li><strong>set names gbk；</strong></li></ul><p>然后再进行插入操作即可解决（但是以上修改只对一次会话生效；如果只会再次使用cmd需要重新设置）</p></blockquote></li></ol><h3 id="select语句："><a href="#select语句：" class="headerlink" title="select语句："></a>select语句：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student;-- 查询所有</span><br><span class="line">select id,name from student; -- 查询指定的字段</span><br><span class="line">select * from student where id=&#x27;1&#x27;;--条件查询</span><br><span class="line"> select * from student where id=&#x27;1&#x27; and sex =&#x27;男&#x27;;--多条件查询</span><br><span class="line">  select * from student where id=&#x27;1&#x27; or sex =&#x27;男&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="update语句（更新）"><a href="#update语句（更新）" class="headerlink" title="update语句（更新）"></a>update语句（更新）</h4><p><strong>语法：</strong></p><p><code>update 表名 set 列名1=值1,列名2=值2... where 条件   </code></p><ol><li><p>修改表中的一条记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tbemp  <span class="keyword">set</span> hiredate<span class="operator">=</span><span class="string">&#x27;2006-03-01&#x27;</span>,age<span class="operator">=</span><span class="number">45</span> <span class="keyword">where</span> eno<span class="operator">=</span><span class="number">4</span>;</span><br></pre></td></tr></table></figure></li><li><p>修改数据(将员工姓名叫旺财的人的月薪提高2000)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tbemp <span class="keyword">set</span> sal<span class="operator">=</span>sal<span class="operator">+</span><span class="number">2000</span> <span class="keyword">where</span> ename<span class="operator">=</span><span class="string">&#x27;旺财&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>修改数据(将员工生日为null的人的生日全部设置为2020-01-01)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tbemp <span class="keyword">set</span> hiredate<span class="operator">=</span><span class="string">&#x27;2020-01-01&#x27;</span> <span class="keyword">where</span> hiredate <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>数据库中是否为空（null）的判断不能使用“&#x3D;”或“!&#x3D;”应该使用 is null或者 is not null</p></blockquote></li></ol><h4 id="delete语句（删除）"><a href="#delete语句（删除）" class="headerlink" title="delete语句（删除）"></a>delete语句（删除）</h4><p><strong>语法：</strong></p><p><code>delete from 表名 where 条件  </code></p><ol><li><p>删除一行指定id的数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbemp <span class="keyword">where</span> eno<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除所有月薪为null的员工</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbemp <span class="keyword">where</span> sal <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><p>实际开发中，数据积累不容易，一般不会轻易使用物理删除；大多数时候会选择使用逻辑删除；所谓逻辑删除实际就是在表中增加一个标识列，通过该列的取值标记该列是否应该被查询到</p><p>因此针对删除需求，可以在表中新增一列用于标记该列是否被删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">alter</span> <span class="keyword">table</span> tbemp <span class="keyword">add</span> isdel tinyint;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h3 id="物理删除："><a href="#物理删除：" class="headerlink" title="物理删除："></a>物理删除：</h3><p>​使用delect 语句直接讲数据库中的数据删除掉</p><h3 id="逻辑删除："><a href="#逻辑删除：" class="headerlink" title="逻辑删除："></a>逻辑删除：</h3><p>​实际上执行的是update语句，更新了该条数据的状态字段，一般状态字段的值：0表示删除，1表示有效</p><p>​如果要做逻辑删除，就是将stats字段的值更新为0,</p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 数据库SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记之Hooks基础</title>
      <link href="/2022/10/08/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BHooks%E5%9F%BA%E7%A1%80-20221008/"/>
      <url>/2022/10/08/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BHooks%E5%9F%BA%E7%A1%80-20221008/</url>
      
        <content type="html"><![CDATA[<h2 id="1-React-Hook-Hooks是什么"><a href="#1-React-Hook-Hooks是什么" class="headerlink" title="1. React Hook&#x2F;Hooks是什么?"></a>1. React Hook&#x2F;Hooks是什么?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). Hook是React 16.8.0版本增加的新特性/新语法</span><br><span class="line">(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</span><br></pre></td></tr></table></figure><h2 id="2-三个常用的Hook"><a href="#2-三个常用的Hook" class="headerlink" title="2. 三个常用的Hook"></a>2. 三个常用的Hook</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). State Hook: React.useState()</span><br><span class="line">(2). Effect Hook: React.useEffect()</span><br><span class="line">(3). Ref Hook: React.useRef()</span><br></pre></td></tr></table></figure><h2 id="3-State-Hook"><a href="#3-State-Hook" class="headerlink" title="3. State Hook"></a>3. State Hook</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作</span><br><span class="line">(2). 语法: const [xxx, setXxx] = React.useState(initValue)  </span><br><span class="line">(3). useState()说明:</span><br><span class="line">        参数: 第一次初始化指定的值在内部作缓存</span><br><span class="line">        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</span><br><span class="line">(4). setXxx()2种写法:</span><br><span class="line">        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</span><br><span class="line">        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span><br></pre></td></tr></table></figure><h2 id="4-Effect-Hook"><a href="#4-Effect-Hook" class="headerlink" title="4. Effect Hook"></a>4. Effect Hook</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)</span><br><span class="line">(2). React中的副作用操作:</span><br><span class="line">        发ajax请求数据获取</span><br><span class="line">        设置订阅 / 启动定时器</span><br><span class="line">        手动更改真实DOM</span><br><span class="line">(3). 语法和说明: </span><br><span class="line">        useEffect(() =&gt; &#123; </span><br><span class="line">          // 在此可以执行任何带副作用操作</span><br><span class="line">          return () =&gt; &#123; // 在组件卸载前执行</span><br><span class="line">            // 在此做一些收尾工作, 比如清除定时器/取消订阅等</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行</span><br><span class="line">    </span><br><span class="line">(4). 可以把 useEffect Hook 看做如下三个函数的组合</span><br><span class="line">        componentDidMount()</span><br><span class="line">        componentDidUpdate()</span><br><span class="line">    componentWillUnmount() </span><br></pre></td></tr></table></figure><h2 id="5-Ref-Hook"><a href="#5-Ref-Hook" class="headerlink" title="5. Ref Hook"></a>5. Ref Hook</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据</span><br><span class="line">(2). 语法: const refContainer = useRef()</span><br><span class="line">(3). 作用:保存标签对象,功能与React.createRef()一样</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端攻坚 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL逻辑体系架构</title>
      <link href="/2022/09/30/MySQL%E9%80%BB%E8%BE%91%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-20221001/"/>
      <url>/2022/09/30/MySQL%E9%80%BB%E8%BE%91%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-20221001/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL逻辑体系架构"><a href="#一、MySQL逻辑体系架构" class="headerlink" title="一、MySQL逻辑体系架构"></a>一、MySQL逻辑体系架构</h2><p> MySQL Server架构自顶向下大致可以分网络连接层、服务层、存储引擎层和系统文件层，具体如下图所示：<br><img src="https://blog.mrquweilin.top/upload/2022/09/1664156731375.png" alt="1664156731375"></p><blockquote><p>自上而下大致可以分为四个层 <strong>网络连接层</strong> 、<strong>数据库服务层</strong>、<strong>存储引擎层</strong>、<strong>系统文件层</strong></p></blockquote><h3 id="网络连接层"><a href="#网络连接层" class="headerlink" title="网络连接层"></a>网络连接层</h3><h4 id="客户端连接器（Client-Connectors）"><a href="#客户端连接器（Client-Connectors）" class="headerlink" title="客户端连接器（Client Connectors）"></a>客户端连接器（Client Connectors）</h4><blockquote><p>提供与MySQL服务器建立的支持。目前几乎支持所有主流 的服务端编程技术，例如常见的 Java、C、Python、.NET等，它们通过各自API技术与MySQL建立连接。 </p></blockquote><h4 id="用户鉴权"><a href="#用户鉴权" class="headerlink" title="用户鉴权"></a>用户鉴权</h4><blockquote><p>当客户端向MySQL服务端发起连接请求后，MySQL server会对发起连接的用户进行鉴权处理，MySQL鉴权依据是: 用户名，客户端主机地址和用户密码 </p></blockquote><h4 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h4><blockquote><p>当客户连接到MySQL server后，MySQL server会根据用户的权限来判断用户具体可执行哪些操作</p><p>MySQL 提供的部分权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;show privileges \G</span><br></pre></td></tr></table></figure></blockquote><h3 id="数据服务层（MySQL-Server）"><a href="#数据服务层（MySQL-Server）" class="headerlink" title="数据服务层（MySQL Server）"></a>数据服务层（MySQL Server）</h3><p> 数据库服务层是整个数据库服务器的核心，主要包括了系统管理和控制工具、连接池、SQL接口、解析器、查询优化器和缓存等部分。 </p><h4 id="系统管理和控制工具"><a href="#系统管理和控制工具" class="headerlink" title="系统管理和控制工具"></a>系统管理和控制工具</h4><blockquote><p>提供数据库系统的管理和控制功能，例如对数据库中的数据进行备份和恢复，保证整个数据库的安全性，提供安全管理，对整个数据库的集群进行协调和管理等。 </p></blockquote><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><blockquote><p>负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接。 </p></blockquote><h4 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h4><blockquote><p>用于接受客户端发送的各种SQL命令，并且返回用户需要查询的结果。比如DML、DDL、存储过程、视图、触发器等。  </p></blockquote><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><blockquote><p>负责将请求的SQL解析生成一个”解析树”。然后根据一些MySQL规则进一步检查解析树是否合法。 </p></blockquote><h4 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h4><blockquote><p>当“解析树”通过解析器语法检查后，将交由优化器将其转化成执行计划，然后与存储引擎交互。 </p></blockquote><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><blockquote><p>缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，权限缓存，引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。 </p></blockquote><h3 id="存储引擎层（Pluggable-Storage-Engines）"><a href="#存储引擎层（Pluggable-Storage-Engines）" class="headerlink" title="存储引擎层（Pluggable Storage Engines）"></a>存储引擎层（Pluggable Storage Engines）</h3><p>存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。MySQL存储引擎是插件式的，服务器中的查询执行引擎通过接口与存储引擎进行通信，接口屏蔽了不同存储引擎之间的差异 。<br>现在有很多种存储引擎，各有各的特点，最常见的是MyISAM和InnoDB。 </p><h3 id="文件系统层（File-System）"><a href="#文件系统层（File-System）" class="headerlink" title="文件系统层（File System）"></a>文件系统层（File System）</h3><p>负责将数据库的数据和日志存储在文件系统之上，并完成与存储引擎的交互，是文件的物理存储层。主要包含日志文件，数据文件，配置文件，pid 文件，socket 文件等。</p><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><ul><li>错误日志（Error log）<br>默认开启，show variables like ‘%log_error%’</li><li>通用查询日志（General query log）<br>记录一般查询语句，show variables like ‘%general%’;</li><li>二进制日志（binary log）<br>记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长；<br>但是它不记录select、show等不修改数据库的SQL。<br>主要用于数据库恢复和主从复制。<br>show variables like ‘%log_bin%’; &#x2F;&#x2F;是否开启<br>show variables like ‘%binlog%’; &#x2F;&#x2F;参数查看<br>show binary logs;&#x2F;&#x2F;查看日志文件</li><li>慢查询日志（Slow query log）<br>记录所有执行时间超时的查询SQL，默认是10秒。<br>show variables like ‘%slow_query%’; &#x2F;&#x2F;是否开启<br>show variables like ‘%long_query_time%’; &#x2F;&#x2F;时长</li></ul><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>用于存放MySQL所有的配置信息文件，比如my.cnf、my.ini等。</p><h4 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h4><ul><li><p>db.opt 文件：记录这个库的默认使用的字符集和校验规则。</p></li><li><p>frm 文件：存储与表相关的元数据（meta）信息，包括表结构的定义信息等，每一张表都会有一个frm 文件。</p></li><li><p>MYD 文件：MyISAM 存储引擎专用，存放 MyISAM 表的数据（data)，每一张表都会有一个.MYD 文件。</p></li><li><p>MYI 文件：MyISAM 存储引擎专用，存放 MyISAM 表的索引相关信息，每一张 MyISAM 表对应一个 .MYI 文件。</p></li><li><p>ibd文件和 IBDATA 文件：存放 InnoDB 的数据文件（包括索引）。</p><p>InnoDB 存储引擎有两种表空间方式：独享表空间和共享表空间。</p><ul><li>独享表空间使用 .ibd 文件来存放数据，且每一张InnoDB 表对应一个 .ibd 文件。<br>享表空间使用 .ibdata 文件，所有表共同使用一个（或多个，自行配置）.ibdata 文件。</li></ul></li><li><p>ibdata1 文件：系统表空间数据文件，存储表元数据、Undo日志等 。</p></li><li><p>ib_logfile0、ib_logfile1 文件：Redo log 日志文件。</p></li></ul><h4 id="pid-文件"><a href="#pid-文件" class="headerlink" title="pid 文件"></a>pid 文件</h4><p>pid 文件是 mysqld 应用程序在 Unix&#x2F;Linux 环境下的一个进程文件，和许多其他 Unix&#x2F;Linux 服务端程序一样，它存放着自己的进程 id。</p><h4 id="socket-文件"><a href="#socket-文件" class="headerlink" title="socket 文件"></a>socket 文件</h4><p>socket 文件也是在 Unix&#x2F;Linux 环境下才有的，用户在 Unix&#x2F;Linux 环境下客户端连接可以不通过TCP&#x2F;IP 网络而直接使用 Unix Socket 来连接 MySQL。</p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 数据库SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式与原则之单一职责原则</title>
      <link href="/2022/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99-20220930/"/>
      <url>/2022/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99-20220930/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单一职责原则"><a href="#一、单一职责原则" class="headerlink" title="一、单一职责原则"></a>一、单一职责原则</h2><h3 id="一、定义（是什么）"><a href="#一、定义（是什么）" class="headerlink" title="一、定义（是什么）"></a>一、定义（是什么）</h3><p>百度上的解释是</p><blockquote><p> <strong>单一职责原则</strong>（SRP：Single responsibility principle）又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定一个类应该只有一个发生变化的原因 。</p></blockquote><p>单一职责原则的原话是（ There should never be more than one reason for a class to change），这个和JAVA强调的高内聚低耦合不谋而合，单一职责见名知意就是说对于一个类来说，应该只有一个引起它变化的原因，应该只有一个职责，而相反的如果出现一个类拥有多个职责，这个类的某个职责的变化就会削弱或者抑制这个类完成其他职责的能力。这会导致脆弱的设计。</p><h3 id="二、优点（为什么）"><a href="#二、优点（为什么）" class="headerlink" title="二、优点（为什么）"></a>二、优点（为什么）</h3><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义;</li><li>可读性提高，复杂性降低，那当然可读性提高了;</li><li>可维护性提高，可读性提高，那当然更容易维护了;</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修 改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大 的帮助。</li></ul><h3 id="三、应用范围（怎么做）"><a href="#三、应用范围（怎么做）" class="headerlink" title="三、应用范围（怎么做）"></a>三、应用范围（怎么做）</h3><p> 单一职责原则适用的范围有接口、方法、类。按大家的说法，接口和方法必须保证单一职责，类就不必保证，只要符合业务就行。 </p><h4 id="①接口方面"><a href="#①接口方面" class="headerlink" title="①接口方面"></a>①接口方面</h4><p>模拟一个场景，一个项目团队开发，A负责前端模块，B负责后端模块则可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DevelopInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">frontDevelop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">baseDevelop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">DevelopInterface</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">frontDevelop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A进行前端开发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">baseDevelop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A进行后端开发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">DevelopInterface</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">frontDevelop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B进行前端开发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">baseDevelop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B进行后端开发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是不符合逻辑的，A只需要进行前端开发，他不需要去实现后端开发的接口，而B只需要后端开发不需要实现前端开发的接口，很明显不符合单一职责原则，改进一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DevelopInterface</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">frontDevelopInterface</span> <span class="keyword">extends</span> <span class="title class_">DevelopInterface</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">frontDevelop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">baseDevelopInterface</span> <span class="keyword">extends</span> <span class="title class_">DevelopInterface</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">baseDevelop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">frontDevelopInterface</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">frontDevelop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A进行前端开发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">baseDevelopInterface</span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">baseDevelop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B进行后端开发&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A和B都没有实现多余的接口，A的前端开发方法实现不会影响到B的后端开发的方法实现，这就是符合单一职责原则，一个类只做一件事. 并且他的修改不会带来其他的变化。</p><h4 id="②方法层面"><a href="#②方法层面" class="headerlink" title="②方法层面"></a>②方法层面</h4><p>模拟一个修改用户密码和修改用户名的接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperateEnum</span> &#123;</span><br><span class="line">    UPDATE_USERNAME,</span><br><span class="line">    UPDATE_PASSWORD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(OperateEnum type, UserInfo userInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOperateImpl</span> <span class="keyword">implements</span> <span class="title class_">UserOperate</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(OperateEnum type, UserInfo userInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == OperateEnum.UPDATE_PASSWORD) &#123;</span><br><span class="line">            <span class="comment">// 修改密码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == OperateEnum.UPDATE_USERNAME) &#123;</span><br><span class="line">            <span class="comment">// 修改用户名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这种方法如果传入的用户n枚举类型有误并持久化到数据库，结果可能是未知的，下面是符合方法层面单一职责原则的接口，每个接口有自己固定的操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUserName</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUserPassword</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOperateImpl</span> <span class="keyword">implements</span> <span class="title class_">UserOperate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserName</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 修改用户名逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserPassword</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 修改密码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="③类层面"><a href="#③类层面" class="headerlink" title="③类层面"></a>③类层面</h4><p>这是一个常见的接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">logIn</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">LogOut</span> <span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"></span><br><span class="line">    UserInfo <span class="title function_">selectByUserName</span> <span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是它的实现类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserOperateImpl implements UserOperate&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void register(UserInfo userInfo) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean logIn(UserInfo userInfo) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean LogOut(UserInfo userInfo) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserInfo selectByUserName(UserInfo userInfo) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 那如果按照单一职责原则拆分, 也可以拆分为下面的形式 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">logIn</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">LogOut</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"></span><br><span class="line">    UserInfo <span class="title function_">selectByUserName</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    UserInfo <span class="title function_">selectByUserName</span><span class="params">(UserInfo userInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOperateImpl</span> <span class="keyword">implements</span> <span class="title class_">UserOperate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">logIn</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">LogOut</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserInfo</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo <span class="title function_">selectByUserName</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写的好处就是使每个类的功能更加内聚化，那么有问题了，那我直接一个接口一个实现类不更加高内聚了吗，其实也是可以的，如果代码量很多的话，这样是可行的。</p><h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h3><p>在日常开发中其实我们很多开发都是违背单一职责原则的， 类的单一职责确实受非常多因素的制约，纯理论地来讲，这个原则是非常优秀的，但是现实有现实的难处，你必须去考虑项目 工期、成本、人员技术水平、硬件情况、网络情况甚至有时候还要考虑政府政策、垄断协议 等因素。 </p><p><strong>因此对于单一职责原则，我的建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化</strong> </p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 设计模式与原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程学习笔记（四）----线程状态</title>
      <link href="/2022/09/23/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89----%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-20220923/"/>
      <url>/2022/09/23/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89----%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-20220923/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>java中的线程创建并启动之后不一定会一致持续执行，会根据程序的执行情况，存在各种不同的状态，之前了解操作系统中的线程分为5中状态（新建，就绪，执行，阻塞，死亡）；但是java中对于线程有其他不同的解释，因此，java中的线程状态在Thread类中有详细表述的。</p><p>Java将线程分为六种状态：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>NEW</td><td>新建状态，该状态表示线程对象创建还未处于可运行状态</td></tr><tr><td>RUNNABLE</td><td>可运行状态，线程处于准备运行或者正在被JVM进行调度执行的状态</td></tr><tr><td>BLOCKED</td><td>锁阻塞状态，线程等待被其他线程占据的对象监视器释放</td></tr><tr><td>WATING</td><td>无限等待，当执行以下对象的相关方法时：Object#wait(),Thread#join(),LockSuport#park()</td></tr><tr><td>TIMED_WATING</td><td>限时等待，当执行以下对象的相关方法时：Thread#sleep(long time),Object#wait(long time)</td></tr><tr><td>TERMINATED</td><td>中止状态，程序正常执行结束。线程销毁</td></tr></tbody></table><p>以上状态可以到Thread.State枚举类中找到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Timed-Wating-计时等待"><a href="#Timed-Wating-计时等待" class="headerlink" title="Timed Wating(计时等待)"></a>Timed Wating(计时等待)</h3><p>计时等待也称之为限时等待，即线程会执行一段时间的休眠，等待休眠时间到达，此时线程自动苏醒</p><h4 id="sleep-long-time"><a href="#sleep-long-time" class="headerlink" title="sleep(long time)"></a>sleep(long time)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimedWatingDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(getName()+<span class="string">&quot;--&gt;&quot;</span>+i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimedWatingDemo</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="wait-long-time"><a href="#wait-long-time" class="headerlink" title="wait(long time)"></a>wait(long time)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimedWatingDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//wait方法的使用必须持有当前对象的对象监视器</span></span><br><span class="line">                    <span class="built_in">this</span>.wait(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;--&gt;&quot;</span> + i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimedWatingDemo</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sleep()和wait()区别？</p><p>sleep:</p><ol><li>sleep()是<strong>Thread类</strong>中提供一个方法，用于实现线程的限时休眠</li><li><strong>sleep()方法的执行不需要持有对象的监视器(不需要获取锁)</strong></li></ol><p>wait:</p><ol><li>wait方法是来自<strong>Object类</strong>中的方法，既可以实现线程的限时休眠，也可以实现线程的无限休眠</li><li><strong>wait方法的使用必须持有对象的监视器</strong>，否则会出现<code>java.lang.IllegalMonitorStateException</code>异常</li><li>wait方法如果处于无限等待状态，则需要其他通过notify或notifyAll唤醒</li><li>wait方法的执行将会释放对象监视器</li></ol></blockquote><h3 id="Blocked-锁阻塞"><a href="#Blocked-锁阻塞" class="headerlink" title="Blocked(锁阻塞)"></a>Blocked(锁阻塞)</h3><p>该状态即一个线程处于等待其他线程释放对象锁的状态，例如死锁案例中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;t1&quot;</span>.equals(name)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;已锁定o1&quot;</span>);</span><br><span class="line">        <span class="comment">//此时t1线程等待其他线程释放o2的对象锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;t2&quot;</span>.equals(name)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;已锁定o2&quot;</span>);</span><br><span class="line">        <span class="comment">//此时t2线程等待其他线程释放o1的对象锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wating-无限等待"><a href="#Wating-无限等待" class="headerlink" title="Wating(无限等待)"></a>Wating(无限等待)</h3><p>当执行对象的某些特定方法时(如Object的wait)，会导致线程处于无限等待状态,即处于不确定何时能恢复执行，具体的恢复时间通常由其他线程进行控制(例如调用Object的notify或notifyAll)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;线程A&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                    System.out.println(getName()+<span class="string">&quot;执行。。。已锁住obj&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//线程A处于无限等待状态（同时会释放obj对象的对象监视器）</span></span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;线程B&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;                </span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                        <span class="comment">//等待5秒之后，线程B会唤醒(同时释放obj对象的对象监视器)</span></span><br><span class="line">                        obj.notify();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wait、notify、notifyAll"><a href="#wait、notify、notifyAll" class="headerlink" title="wait、notify、notifyAll"></a>wait、notify、notifyAll</h2><ul><li>wait()：方法的执行会导致当前线程处于无限等待状态，只有其他具备该对象监视器的对象执行notify或notifyAll时才能将其唤醒</li><li>notify()：唤醒等待当前对象的对象监视器的单个线程</li><li>notifyAll()：唤醒等待当前对象对象监视器的所有线程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程学习笔记（三）----多线程放号器（案例）</title>
      <link href="/2022/09/23/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%BE%E5%8F%B7%E5%99%A8%EF%BC%88%E6%A1%88%E4%BE%8B%EF%BC%89-20220922/"/>
      <url>/2022/09/23/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%BE%E5%8F%B7%E5%99%A8%EF%BC%88%E6%A1%88%E4%BE%8B%EF%BC%89-20220922/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberGen</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RandomAccessFile raf;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> over;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;day5-Thread/record.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            num = raf.readInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (EOFException e)&#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前没有号码记录，重新放号&quot;</span>);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!over)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取号码:&quot;</span> + num);</span><br><span class="line">                    <span class="comment">//将文件指针设置到开头处</span></span><br><span class="line">                    raf.seek(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//将当前号码记录到文件中</span></span><br><span class="line">                    raf.writeInt(num);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(raf != <span class="literal">null</span>)&#123;</span><br><span class="line">                raf.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> over;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOver</span><span class="params">(<span class="type">boolean</span> over)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.over = over;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NumberGen</span> <span class="variable">ng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberGen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ng,<span class="string">&quot;放号机A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ng,<span class="string">&quot;放号机B&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ng,<span class="string">&quot;放号机C&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程学习笔记（二）----线程并发问题</title>
      <link href="/2022/09/22/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89----%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98-20220921/"/>
      <url>/2022/09/22/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89----%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98-20220921/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在多线程操作共享变量时可能会遇到如下问题：</p><p>例如：银行取钱，现有多个用户操作同一个账户，可能会遇到并发安全问题，假设一个账户中余额一共10000元，现在有多个用户同时通过该账户取款，各取10000；取款的过程必然会先进行余额检查，如果余额足够则允许取款；如果过个用户将取款的时间恰好定在同一个时刻，此时就可能出现这些用户同时取款成功的情况，但是实际账户的余额与预期的结果出现不一致。</p><p>以上问题就称之为<strong>线程安全</strong>问题；所谓线程安全问题：即多线程并发操作共享变量时造成的结果污染问题</p><h3 id="案例场景"><a href="#案例场景" class="headerlink" title="案例场景"></a>案例场景</h3><p>类似以上线程安全问题有很多：</p><ul><li>购票</li><li>限时秒杀</li></ul><h3 id="并发编程有三要素"><a href="#并发编程有三要素" class="headerlink" title="并发编程有三要素"></a>并发编程有三要素</h3><ul><li>原子性：线程是原子操作的，要么都成功，要么都失败</li><li>可见性：多个线程并发操作时，一个线程对共享变量的修改要实时的同步到其他线程中</li><li>有序性：线程内部的程序执行，由上而下依次执行。(避免指令重排)</li></ul><h2 id="线程同步解决方案"><a href="#线程同步解决方案" class="headerlink" title="线程同步解决方案"></a>线程同步解决方案</h2><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>synchronized是java中提供一个用于实现线程同步的关键字，通过使用该关键字，可以有效的解决线程并发时线程安全的问题，解决的并发编程中的原子性。synchronized有三种使用方式：</p><ul><li>对象锁（使用synchronized关键对对象&#x2F;实例锁定）</li><li>方法锁（使用synchronized对方法修饰锁定方法）</li><li>类锁（使用synchronized直接锁定类）</li></ul><h4 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountOperation</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Account a;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待取款金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountOperation</span><span class="params">(Account a, <span class="type">double</span> target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            a.giveMoney(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法锁"><a href="#方法锁" class="headerlink" title="方法锁"></a>方法锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">(<span class="type">double</span> m)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= money)&#123;</span><br><span class="line">        money -= m;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;取款成功，余额：&quot;</span> + money);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;余额不足，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;取款失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">(<span class="type">double</span> m)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Account.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= money)&#123;</span><br><span class="line">            money -= m;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;取款成功，余额：&quot;</span> + money);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额不足，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;取款失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类锁的另一种写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">(<span class="type">double</span> m)</span>&#123;    </span><br><span class="line">&gt;<span class="keyword">if</span>(m &lt;= money)&#123;</span><br><span class="line">   money -= m;</span><br><span class="line">   System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;取款成功，余额：&quot;</span> + money);</span><br><span class="line">&gt;&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;余额不足，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;取款失败!&quot;</span>);</span><br><span class="line">&gt;&#125;  </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><p>使用锁虽然能够解决多线程访问共享变量造成的安全问题，但是如果使用不当，也有可能会导致死锁；</p><p>死锁即多个线程等待被对方线程占有的资源时陷入一个僵局。</p><p><img src="https://blog.mrquweilin.top/upload/2022/09/1610614118889.png" alt="1610614118889"></p><p>参考代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;t1&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;已锁定o1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;t2&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;已锁定o2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>在Java5中新增的并发编程包中，提供一种新型的锁机制<code>Lock</code>,提供了比synchronized功能更为强大的锁，<code>Lock</code>是一个接口，主要的实现类是<code>ReentrantLock</code>（可重入锁），提供了公平锁与非公平锁机制，默认是非公平锁的实现。</p><p>用法如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//获取锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买到车票：&quot;</span> + (--count));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SaleTickets</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SaleTickets</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st,<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st,<span class="string">&quot;小王&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意事项</p><p>由于Lock是手动获取以及释放锁（区别synchronized自动锁机制），因此一般锁的获取会放在try语句块之前，并且对于锁的释放如果使用的位置不恰当,很有可能造成死锁，因此建议将锁的释放定义在finally语句块中</p><p>synchornized和lock区别？</p><p>synchronized：</p><ul><li>是java中提供的一个关键字</li><li>synchronized锁在任务执行完毕之后会自动释放</li><li>synchronized是一种非公平锁</li><li>synchronized适用于少量的代码片段</li></ul><p>lock：</p><ul><li>是一个java类，提供的功能要强大于synchronized</li><li>锁的释放需要手动控制，因此可以控制粒度更为细腻的操作</li><li>lock既可以使用公平锁，也可以使用非公平锁实现</li><li>lock适用于大量代码片段的锁机制</li></ul></blockquote><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>在了解volatile之前，先看以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> isOver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程启动&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!isOver)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程终止。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">VolatileDemo</span> <span class="variable">vd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(vd);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        vd.isOver = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​分析以上程序，启动了两条线程，其中主线程中等待三秒之后会将结束标记修改，正常情况下，被修改的变量值应该立即被子线程读取，从而结束子线程；但是实际情况是，子线程并未结束，而是一直循环执行。</p><p>​产生原因如下：</p><p><img src="https://blog.mrquweilin.top/upload/2022/09/1610613660958.png" alt="1610613660958"></p><p>如果需要将线程中对变量的修改立即同步给其他线程，只需要将变量使用<code>volatile</code>关键字修饰即可:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> isOver;</span><br></pre></td></tr></table></figure><p>volatile可以保证数据的<strong>可见性</strong>以及<strong>有序性</strong>（不会进行指令重排），但是不保证原子性。</p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JAVA线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记之压缩命令</title>
      <link href="/2022/09/08/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4-20220912/"/>
      <url>/2022/09/08/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4-20220912/</url>
      
        <content type="html"><![CDATA[<ol><li><p>   压缩文件（该命令只能压缩文件）<br>1）命令：gzip 文件名称（或gunzip 文件名）<br><img src="https://blog.mrquweilin.top/upload/2022/09/image.png" alt="image"><br>2）解压缩<br>命令：gzip -d 压缩文件的名称<br><img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458853428.png" alt="image-1662458853428"><br>3）zcat命令<br>读取压缩文件名<br><img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458864201.png" alt="image-1662458864201"></p></li><li><p>   bzip2压缩命令（只能解压文件）<br> 1）语法 bzip2 文件名<br> <img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458892370.png" alt="image-1662458892370"><br>2）读取压缩文件内容<br>语法 bzcat 压缩文件名<br> <img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458898080.png" alt="image-1662458898080"><br>3）解压缩文件<br>语法：bzip2 -d 压缩文件名<br> <img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458903410.png" alt="image-1662458903410"></p></li><li><p>   tar命令<br> <img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458911258.png" alt="image-1662458911258"><br>1）打包目录，文件<br>语法：tar -cvf(表示执行方式) mydiv.tar(打包文件命令) 目录1 目录2  文件1 文件2<br> <img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458919124.png" alt="image-1662458919124"><br>解压打包的文件<br>语法：tar -xvf(执行方式) mydiv.tar(打包好的文件) -C  路径<br> <img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458923411.png" alt="image-1662458923411"></p></li></ol><p>2）打包并且压缩（czvf(z–gzip)和civf(bzip2<br>语法：tar -czvf(执行权限) 路径&#x2F;文件名（自己命名） 文件1 目录1<br> <img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458927410.png" alt="image-1662458927410"></p><p>3）将打包压缩的文件解压到指定文件<br>语法： tar -zxvf  路径（要解压文件的路径） -C 路径（解压到的指定路径） （原压缩文件还存在）<br> <img src="https://blog.mrquweilin.top/upload/2022/09/image-1662458930941.png" alt="image-1662458930941"></p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA activiti6回退和跳转功能实现</title>
      <link href="/2022/08/24/JAVA%20activiti6%E5%9B%9E%E9%80%80%E5%92%8C%E8%B7%B3%E8%BD%AC%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-20220824/"/>
      <url>/2022/08/24/JAVA%20activiti6%E5%9B%9E%E9%80%80%E5%92%8C%E8%B7%B3%E8%BD%AC%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-20220824/</url>
      
        <content type="html"><![CDATA[<h2 id="事件起因"><a href="#事件起因" class="headerlink" title="事件起因"></a>事件起因</h2><p>最近突然让我做一个工作流跳转和退回到指定节点，说是用activiti写的，这我哪会，直接措手不及啊<br><img src="https://blog.mrquweilin.top/upload/2022/08/image-1661309011773.png" alt="image-1661309011773"></p><p>回去以后恶补了一下，大概是了解了，不多说，直接进入正题。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>一上手，直接面向百度编程了一波，结果发现都让我改模型，改了不就崩了吗，我不能理解。<br>首先分析一下，要实现跳转得搞清楚几个问题，首先我们是改模型或者实例还是改数据（就是改这个流程现在的人员），首先排除改数据，数据改了，流程不还是继续往前吗，明显不行，再排除改模型，改了模型重新部署，这整个流程不就不对了吗，最后只剩下改实例了</p><h4 id="修改实例"><a href="#修改实例" class="headerlink" title="修改实例"></a>修改实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取任务信息</span></span><br><span class="line"><span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery().taskId(taskId).singleResult();</span><br><span class="line"><span class="comment">// 获取实例id</span></span><br><span class="line"><span class="type">String</span> <span class="variable">processDefinitionId</span> <span class="operator">=</span> runtimeService.createProcessInstanceQuery().processInstanceId(task.getProcessInstanceId()).singleResult().getProcessDefinitionId();</span><br><span class="line"><span class="comment">// 获取模型配置信息</span></span><br><span class="line"><span class="type">BpmnModel</span> <span class="variable">bpmnModel</span> <span class="operator">=</span> repositoryService.getBpmnModel(processDefinitionId);</span><br><span class="line"><span class="comment">// 获取实例信息</span></span><br><span class="line"><span class="type">Execution</span> <span class="variable">execution</span> <span class="operator">=</span> runtimeService.createExecutionQuery().executionId(task.getExecutionId()).singleResult();</span><br></pre></td></tr></table></figure><p>这个时候遇到问题了，完蛋了，我回退啥啊，我都不知道回退到哪，我咋回退，所以我们还需要写一个查询当前节点以前所有节点递归接口</p><h4 id="查节点"><a href="#查节点" class="headerlink" title="查节点"></a>查节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归查找当前节点前用户节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentFlowNode 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 所有节点map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chooseNode 可选的节点集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;FlowElement&gt; <span class="title function_">recursionSearch</span><span class="params">(FlowNode currentFlowNode, Map&lt;String, List&lt;FlowElement&gt;&gt; map, List&lt;FlowElement&gt; chooseNode,List&lt;SequenceFlow&gt; lineList)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取输入线</span></span><br><span class="line">        List&lt;SequenceFlow&gt; incomingFlows = currentFlowNode.getIncomingFlows();</span><br><span class="line">        <span class="comment">// 判断输入线类型</span></span><br><span class="line">        <span class="keyword">for</span> (SequenceFlow incomingFlow : incomingFlows) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是网关节点</span></span><br><span class="line">            <span class="keyword">if</span> (map.get(<span class="string">&quot;gateway&quot;</span>).stream().filter(e -&gt; e.getId().equals(incomingFlow.getSourceRef())).collect(Collectors.toList()).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//是网关节点，继续找上个节点找到后继续加入递归</span></span><br><span class="line">                List&lt;FlowElement&gt; gateway = map.get(<span class="string">&quot;gateway&quot;</span>).stream().filter(e -&gt; e.getId().equals(incomingFlow.getSourceRef())).collect(Collectors.toList());</span><br><span class="line">                <span class="type">FlowNode</span> <span class="variable">gatewayNode</span> <span class="operator">=</span>   (FlowNode)gateway.get(<span class="number">0</span>);</span><br><span class="line">                List&lt;SequenceFlow&gt; gatewayNodeIncomingFlows = gatewayNode.getIncomingFlows();</span><br><span class="line">                List&lt;SequenceFlow&gt; outgoingFlows = gatewayNode.getOutgoingFlows();</span><br><span class="line">                <span class="keyword">if</span>(gatewayNodeIncomingFlows.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    List&lt;FlowElement&gt; userTask = map.get(<span class="string">&quot;userTask&quot;</span>).stream().filter(e -&gt; e.getId().equals(gatewayNodeIncomingFlows.get(<span class="number">0</span>).getSourceRef())).collect(Collectors.toList());</span><br><span class="line">                    List&lt;String&gt; targetRefs = outgoingFlows.stream().map(t -&gt; t.getTargetRef()).collect(Collectors.toList());</span><br><span class="line">                    List&lt;String&gt; startOrEnd = map.get(<span class="string">&quot;startOrEnd&quot;</span>).stream().map(t -&gt; t.getId()).collect(Collectors.toList());</span><br><span class="line">                    targetRefs.retainAll(startOrEnd);</span><br><span class="line">                    <span class="keyword">if</span>(userTask.size() &gt; <span class="number">0</span> &amp;&amp; targetRefs.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(Objects.nonNull(lineList))&#123;</span><br><span class="line">                            lineList.add((incomingFlow));</span><br><span class="line">                            lineList.addAll(gatewayNodeIncomingFlows);</span><br><span class="line">                        &#125;</span><br><span class="line">                        FlowNode flowNode=  (FlowNode)userTask.get(<span class="number">0</span>);</span><br><span class="line">                        chooseNode.add(flowNode);</span><br><span class="line">                        chooseNode.add(gateway.get(<span class="number">0</span>));</span><br><span class="line">                        recursionSearch(flowNode,map,chooseNode,lineList);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是开始节点，直接加入数组，结束循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (map.get(<span class="string">&quot;startOrEnd&quot;</span>).stream().filter(e -&gt; e.getId().equals(incomingFlow.getSourceRef())).collect(Collectors.toList()).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(Objects.nonNull(lineList))&#123;</span><br><span class="line">                    lineList.add((incomingFlow));</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;FlowElement&gt; startOrEnd = map.get(<span class="string">&quot;startOrEnd&quot;</span>).stream().filter(e -&gt; e.getId().equals(incomingFlow.getSourceRef())).collect(Collectors.toList());</span><br><span class="line">                <span class="keyword">if</span> (Objects.nonNull(startOrEnd.get(<span class="number">0</span>)))&#123;</span><br><span class="line">                    chooseNode.add(startOrEnd.get(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非网关节点，非开始节点，即用户节点，加入当前节点，继续递归</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(map.get(<span class="string">&quot;userTask&quot;</span>).stream().filter(e -&gt; e.getId().equals(incomingFlow.getSourceRef())).collect(Collectors.toList()).size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Objects.nonNull(lineList))&#123;</span><br><span class="line">                    lineList.add((incomingFlow));</span><br><span class="line">                &#125;</span><br><span class="line">                chooseNode.add(currentFlowNode);</span><br><span class="line">             <span class="comment">//   找到上个节点</span></span><br><span class="line">                List&lt;FlowElement&gt; userTask = map.get(<span class="string">&quot;userTask&quot;</span>).stream().filter(e -&gt; e.getId().equals(incomingFlow.getSourceRef())).collect(Collectors.toList());</span><br><span class="line">                <span class="type">FlowNode</span> <span class="variable">flowElement</span> <span class="operator">=</span> (FlowNode)userTask.get(<span class="number">0</span>);</span><br><span class="line">                recursionSearch(flowElement,map,chooseNode,lineList);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chooseNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个查节点其实有一定的约束性，遇到并行可选的节点可能需要根据具体做出改变。<br>这样下来节点有了，可以开始下一步了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强制跳转节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taskId 任务id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sid 节点id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> variables</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">forceNode1</span><span class="params">(String taskId, String sid,String comment,Map&lt;String, Object&gt; variables,Long flowVoId)</span>&#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery().taskId(taskId).singleResult();</span><br><span class="line">        <span class="type">String</span> <span class="variable">processDefinitionId</span> <span class="operator">=</span> runtimeService.createProcessInstanceQuery().processInstanceId(task.getProcessInstanceId()).singleResult().getProcessDefinitionId();</span><br><span class="line">        <span class="type">BpmnModel</span> <span class="variable">bpmnModel</span> <span class="operator">=</span> repositoryService.getBpmnModel(processDefinitionId);</span><br><span class="line">        <span class="type">Execution</span> <span class="variable">execution</span> <span class="operator">=</span> runtimeService.createExecutionQuery().executionId(task.getExecutionId()).singleResult();</span><br><span class="line">        <span class="type">String</span> <span class="variable">activityId</span> <span class="operator">=</span> execution.getActivityId();</span><br><span class="line">        <span class="type">FlowNode</span> <span class="variable">currentFlowNode</span> <span class="operator">=</span>  (FlowNode)bpmnModel.getMainProcess().getFlowElement(activityId);</span><br><span class="line">        <span class="type">FlowNode</span> <span class="variable">targetFlowNode</span> <span class="operator">=</span>  (FlowNode)bpmnModel.getMainProcess().getFlowElement(sid);</span><br><span class="line">        <span class="comment">//拉线</span></span><br><span class="line">        List&lt;SequenceFlow&gt; sequenceFlowList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">SequenceFlow</span> <span class="variable">sequenceFlow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceFlow</span>();</span><br><span class="line">        sequenceFlow.setId(<span class="string">&quot;newFlow&quot;</span>);</span><br><span class="line">        sequenceFlow.setSourceFlowElement(currentFlowNode);</span><br><span class="line">        sequenceFlow.setTargetFlowElement(targetFlowNode);</span><br><span class="line">        sequenceFlowList.add(sequenceFlow);</span><br><span class="line">        <span class="comment">// 备份原有</span></span><br><span class="line">        List&lt;SequenceFlow&gt; dataflows = currentFlowNode.getOutgoingFlows();</span><br><span class="line">        List&lt;SequenceFlow&gt; oriSequenceFlows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SequenceFlow&gt;();</span><br><span class="line">        oriSequenceFlows.addAll(dataflows);</span><br><span class="line">        currentFlowNode.getOutgoingFlows().clear();</span><br><span class="line">        currentFlowNode.setOutgoingFlows(sequenceFlowList);</span><br><span class="line">        comment = <span class="string">&quot;【回退】&quot;</span>+comment;</span><br><span class="line">        taskService.addComment(taskId, task.getProcessInstanceId(), comment);</span><br><span class="line"><span class="comment">//        taskService.resolveTask(taskId, variables);</span></span><br><span class="line">        taskService.claim(taskId, ShiroUtils.getLoginName());</span><br><span class="line">        taskService.complete(taskId);</span><br><span class="line">        currentFlowNode.setOutgoingFlows(oriSequenceFlows);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意一点，你改完线以后一定要先备份，再拉回去，不然下一个实例会有问题，但是多线程会不会有问题呢，这个值得思考一下<br>到这就结束了？<br><img src="https://blog.mrquweilin.top/upload/2022/08/image-1661309037890.png" alt="image-1661309037890"><br>写了，用户难道不查历史的吗，你这样历史不乱套了吗<br>所以在历史上还得动手脚</p><h4 id="修改历史"><a href="#修改历史" class="headerlink" title="修改历史"></a>修改历史</h4><p>可以先查出所有历史，给加签节点赋值时间，最后按节点时间排序不就成了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;FlowVo&gt; flowVoList = results.stream().filter(e -&gt; e.getTaskId() != <span class="literal">null</span> &amp;&amp; e.getTaskId().equals(bizIncrease.getTaskId()) &amp;&amp; e.getTaskName() != <span class="string">&quot;加签节点&quot;</span>).collect(Collectors.toList());</span><br><span class="line">                   <span class="keyword">if</span>(taskName == <span class="literal">null</span> || taskName.length() == <span class="number">0</span> || taskName.equals(<span class="string">&quot;加签节点&quot;</span>))&#123;</span><br><span class="line">                       <span class="keyword">if</span>(flowVoList.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                           <span class="comment">// 说明是历史</span></span><br><span class="line">                           <span class="keyword">for</span> (FlowVo vo : flowVoList) &#123;</span><br><span class="line">                               <span class="type">FlowVo</span> <span class="variable">newFlow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowVo</span>();</span><br><span class="line">                               BeanUtils.copyProperties(vo, newFlow);</span><br><span class="line">                               newFlow.setTaskId(bizIncrease.getTaskId());</span><br><span class="line">                               newFlow.setTaskName(<span class="string">&quot;加签节点&quot;</span>);</span><br><span class="line">                               <span class="keyword">if</span>(bizIncrease.getIsHandle().equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">                                   newFlow.setStartTime(bizIncrease.getTaskCreateTime());</span><br><span class="line">                               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                   newFlow.setStartTime(bizIncrease.getStartTime());</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="type">SysUser</span> <span class="variable">sysUser</span> <span class="operator">=</span> userMapper.selectUserByLoginName(vo.getApplyUser());</span><br><span class="line">                               newFlow.setApplyUserName(sysUser.getUserName());</span><br><span class="line">                               newFlow.setEndTime(bizIncrease.getStartTime());</span><br><span class="line">                               results.add(newFlow);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">                           <span class="comment">// 说明是当前的</span></span><br><span class="line">                           <span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.createProcessInstanceQuery().processInstanceId(bizIncrease.getInstanceId()).singleResult();</span><br><span class="line">                           <span class="type">String</span> <span class="variable">businessKey</span> <span class="operator">=</span> processInstance.getBusinessKey();</span><br><span class="line">                           <span class="type">FlowVo</span> <span class="variable">flow1</span> <span class="operator">=</span> activityJobMapper.selectActivityJobById(<span class="keyword">new</span> <span class="title class_">Long</span>(businessKey));</span><br><span class="line">                           flow1.setTaskId(bizIncrease.getTaskId());</span><br><span class="line">                           flow1.setTaskName(<span class="string">&quot;加签节点&quot;</span>);</span><br><span class="line">                           flow1.setEndTime(bizIncrease.getStartTime());</span><br><span class="line">                           <span class="keyword">if</span>(bizIncrease.getIsHandle().equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">                               flow1.setStartTime(bizIncrease.getTaskCreateTime());</span><br><span class="line">                           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                               flow1.setStartTime(bizIncrease.getStartTime());</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="type">SysUser</span> <span class="variable">sysUser</span> <span class="operator">=</span> userMapper.selectUserByLoginName(flow1.getApplyUser());</span><br><span class="line">                           flow1.setApplyUserName(sysUser.getUserName());</span><br><span class="line">                           results.add(flow1);</span><br><span class="line">                       &#125;</span><br></pre></td></tr></table></figure><p>思路大概是这样。<br>这样强制跳转和回退就写好了。后面其实还有加签和委派两个功能，其实都类似<br><img src="https://blog.mrquweilin.top/upload/2022/08/image-1661308990979.png" alt="image-1661308990979"></p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> activiti工作流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 泛型</title>
      <link href="/2022/08/23/JAVA%20%E6%B3%9B%E5%9E%8B-20220823/"/>
      <url>/2022/08/23/JAVA%20%E6%B3%9B%E5%9E%8B-20220823/</url>
      
        <content type="html"><![CDATA[<p>JDK1.5之前对于集合中元素的存储可以是任意的数据类型，在实际开发中就可能遇到类似以下问题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">list.add(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">    System.out.println(s.length()); <span class="comment">//程序运行出现 java.lang.ClassCastException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于以上代码<strong>运行期间</strong>会出现类型转换异常，解决方案修改为如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">  System.out.println(s.length());</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>在JDK1.5之前只能使用以上解决方案，但是这样一来会增加时间的开销。</p></blockquote><p>从JDK1.5之后，Java开始引入了泛型机制，通过使用泛型可以将原本在程序运行时才能检测的异常，提前到编译期；从而减少一些不必要程序运行时间开销：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="number">10</span>); <span class="comment">// 编译错误 类型不支持</span></span><br><span class="line">list.add(<span class="literal">true</span>); <span class="comment">//编译错误 类型不支持</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>泛型即<strong>参数化类型</strong>，将一种数据类型作为参数传递到指定的位置，作用在于<strong>可以将原本在运行时才能提示的异常（ClassCastException），提前到编译期间</strong>；语法为使用一对<code>&lt;&gt;</code>内部包裹具体的<strong>引用类型</strong></p><p>定义泛型时可以使用一些特殊的类型符号表示，常见：</p><ul><li>T：Type</li><li>E：Element</li><li>K：Key</li><li>V：Value</li><li>…</li></ul><p>案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt;</span><br><span class="line">Comparable&lt;T&gt;</span><br><span class="line">Map&lt;K，V&gt;</span><br></pre></td></tr></table></figure><p>使用案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list;</span><br><span class="line">Map&lt;String,Object&gt; map;</span><br><span class="line">Comparable&lt;User&gt;</span><br></pre></td></tr></table></figure><p>java中的泛型分为三种使用方式：</p><ul><li><strong>泛型类</strong></li><li><strong>泛型接口</strong></li><li><strong>泛型方法</strong></li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类即在一个普通的类中使用泛型表达式设定泛型参数，在类中可以将泛型作为参数以及返回值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfo</span><span class="params">(T obj)</span> &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student)obj;</span><br><span class="line">System.out.println(s.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(T t)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;删除。。。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//反射</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">t.setName(<span class="string">&quot;仓老师&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">stu.setName(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line"></span><br><span class="line">Service&lt;Student&gt; s = <span class="keyword">new</span> <span class="title class_">Service</span>&lt;Student&gt;();</span><br><span class="line">s.showInfo(stu);</span><br><span class="line">s.del(stu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型的使用可以同时传递多种参数类型，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service2</span>&lt;U,S,T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showUser</span><span class="params">(U u)</span> &#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)u;</span><br><span class="line">System.out.println(<span class="string">&quot;用户名：&quot;</span>+user.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showStu</span><span class="params">(S s)</span> &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)s;</span><br><span class="line">System.out.println(<span class="string">&quot;学生名：&quot;</span>+stu.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showTeacher</span><span class="params">(T t)</span> &#123;</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> (Teacher)t;</span><br><span class="line">System.out.println(<span class="string">&quot;老师名：&quot;</span>+teacher.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">t.setName(<span class="string">&quot;仓老师&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">stu.setName(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;红孩儿&quot;</span>);</span><br><span class="line"><span class="comment">//jdk1.7之后泛型的定义只需要在声明时指定即可</span></span><br><span class="line">Service2&lt;User,Student,Teacher&gt; s = <span class="keyword">new</span> <span class="title class_">Service2</span>&lt;&gt;();</span><br><span class="line">s.showStu(stu);</span><br><span class="line">s.showTeacher(t);</span><br><span class="line">s.showUser(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常见的泛型类:</p><p>java.util.ArrayList&#x2F;java.util.LinkedList</p><p>java.util.HashSet&#x2F;java.util.TreeSet</p><p>…</p></blockquote><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口即在声明接口时，指定泛型参数，当实现类对接口实现时，只需要在实现的接口之后指定具体类型，在方法中即可将参数(返回值)类型确定为目标类型，从而避免了强制转换操作。</p><p><strong>接口定义:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IManager</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(T o)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现类1:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManager</span> <span class="keyword">implements</span> <span class="title class_">IManager</span>&lt;User&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(User o)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(User o)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>实现类2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OfficeManager</span> <span class="keyword">implements</span> <span class="title class_">IManager</span>&lt;Office&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Office o)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Office&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Office o)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常见接口泛型：</p><p>java.util.Collection</p><p>java.util.List</p><p>java.util.Set</p><p>java.util.Map</p></blockquote><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法指的是单独定义一个方法，在方法声明时指定泛型参数，此时该泛型参数可用作于当前方法的返回值类型或者参数类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(T t)</span> &#123;</span><br><span class="line"><span class="comment">//反射实现具体操作</span></span><br><span class="line">System.out.println(t);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">t.setName(<span class="string">&quot;仓老师&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">stu.setName(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;红孩儿&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Admin</span> <span class="variable">admin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">tea</span> <span class="operator">=</span> get(t);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> get(stu);</span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> get(user);</span><br><span class="line"><span class="type">Admin</span> <span class="variable">a</span> <span class="operator">=</span> get(admin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>泛型方法在一些开源项目中比较常见:</p><p>fastJSON</p></blockquote><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>在对泛型类型不确定时可以使用通配符的方式表示，泛型通配符包含以下几种：</p><ul><li>&lt; ?  &gt;</li><li>&lt; ? extends T &gt;</li><li>&lt; ？ super T &gt;</li></ul><h4 id="上界限定（extends）"><a href="#上界限定（extends）" class="headerlink" title="上界限定（extends）"></a>上界限定（extends）</h4><p>上界限定即：规定传入集合中的元素必须是目标元素对象或者其子类对象，并且上界限定后，集合中的元素只出不进（不能调用add），一般用于方法的参数接收定义和返回值类型定义。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上界限定：只出不进（只能获取元素，不能进行修改）规定传入的集合元素只能是People或者People子类对象集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;? extends People&gt; list)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (People p : list) &#123;</span><br><span class="line">System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line">list.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//不允许新增（任何类型）</span></span><br><span class="line"><span class="comment">//list.add(new User());</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//java编译器中存在类型擦除机制(编译器不理解泛型)</span></span><br><span class="line"><span class="comment">//List&lt;People&gt; list = new ArrayList&lt;User&gt;(); // 编译错误</span></span><br><span class="line"></span><br><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上界限定:规定集中能够存储的元素只能是Object或者Object的子类对象</span></span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">users.add(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">users.add(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">users.add(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">test(users); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果直接为泛型指定<code>&lt;?&gt;</code>即表示为<code>&lt;? extends Object&gt;</code></p></blockquote><h4 id="下界限定（super）"><a href="#下界限定（super）" class="headerlink" title="下界限定（super）"></a>下界限定（super）</h4><p>下界限定即:限定元素的下边界，存入的元素只能是当前类的对象或者存在继承关系的子类对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下界限定:限定传入元素的下边界，存入的元素只能是当前类的对象或者存在继承关系的子类对象</span></span><br><span class="line">List&lt;? <span class="built_in">super</span> User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;People&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line"><span class="comment">//list.add(new People());</span></span><br><span class="line"><span class="comment">//list.add(new Object());</span></span><br><span class="line"><span class="comment">//只进不出(出来的任何元素都只能是Object)</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">list.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>PECS：Product Extends Consumer Super</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化基础</title>
      <link href="/2022/08/05/MySQL%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80-20220810/"/>
      <url>/2022/08/05/MySQL%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80-20220810/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql基础"><a href="#MySql基础" class="headerlink" title="MySql基础"></a>MySql基础</h1><h2 id="一、引擎"><a href="#一、引擎" class="headerlink" title="一、引擎"></a>一、引擎</h2><h4 id="1、引擎选择"><a href="#1、引擎选择" class="headerlink" title="1、引擎选择"></a>1、引擎选择</h4><table><thead><tr><th align="center">引擎</th><th align="center">特点</th><th align="center">场景</th><th>调优</th></tr></thead><tbody><tr><td align="center">InnoDB(5.5以后默认)</td><td align="center">支持热备份、存储限制（64TB）、支持事务、支持四隔离级别、支持外键、行级锁定、能缓存数据也能缓存索引</td><td align="center">①业务相关（银行转账等）②适合高并发，行级锁可以支持高并发不至于锁表，但需要确保查询是通过索引完成的③数据修改频繁的业务</td><td>①主键尽量小②避免全表扫描③尽量缓存索引和数据④避免主键更新</td></tr><tr><td align="center">MyISAM</td><td align="center">不支持事务、表级锁定（更新时锁定整个表）、读写互相阻塞。只会缓存索引。读取速度快、不支持外键、支持全文索引</td><td align="center">①不需要业务的场景②读数据多的③数据修改量少的④数据一致性要求不高的</td><td>①设置适合的索引②启用延迟写入，避免频繁写入③尽量顺序inset④降低并发数⑤MyISAM的count只有全表扫描比较高效，带有其它条件都需要进行实际数据访问</td></tr><tr><td align="center">Archive</td><td align="center">只支持INSERT和SELECT，I&#x2F;O更少、SELECT需全表、支持行级锁定、非事务引擎</td><td align="center">日志和数据采集应用</td><td></td></tr><tr><td align="center">Blackhole</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">CSV</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">Federated</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">Memory</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">Merge</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">NDB</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">第三方</td><td align="center"></td><td align="center"></td><td></td></tr></tbody></table><p>大部分情况下采用innoDB</p><h4 id="2、引擎切换"><a href="#2、引擎切换" class="headerlink" title="2、引擎切换"></a>2、引擎切换</h4><h5 id="①alter-table"><a href="#①alter-table" class="headerlink" title="①alter table"></a>①alter table</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table mytable engine = InnoDB;</span><br></pre></td></tr></table></figure><h5 id="②导出导入"><a href="#②导出导入" class="headerlink" title="②导出导入"></a>②导出导入</h5><pre><code>     使用mysqldump工具 （musqldump工具在create table 之前会drop table）</code></pre><h5 id="③创建与查询"><a href="#③创建与查询" class="headerlink" title="③创建与查询"></a>③创建与查询</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table innodb_table like myisam_table;</span><br><span class="line">alter table innnodb_table engine =  InnoDB;</span><br><span class="line">// 数据量比较大的时候可以采用between and 分割</span><br><span class="line">insert into innnodb_table select * from myisam_table</span><br></pre></td></tr></table></figure><h2 id="二、基准测试"><a href="#二、基准测试" class="headerlink" title="二、基准测试"></a>二、基准测试</h2><h4 id="1、基准测试指标"><a href="#1、基准测试指标" class="headerlink" title="1、基准测试指标"></a>1、基准测试指标</h4><p>①吞吐量</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">单位时间内事务的处理数</span><br></pre></td></tr></table></figure><p>②响应时间或延迟</p><p>③并发性</p><p>④可拓展性</p><h4 id="2、测试工具"><a href="#2、测试工具" class="headerlink" title="2、测试工具"></a>2、测试工具</h4><p>集成式：①ab ②http_load ③ JMeter</p><p>单组件式： ① mysqlsap ② MySQL Benchmark Suite（sql-bench）③ Super Smack ④ Database Test Suite ⑤ Percona’s TPCC-MySQL Tool ⑥ sysbench</p><h2 id="三、数据类型优化"><a href="#三、数据类型优化" class="headerlink" title="三、数据类型优化"></a>三、数据类型优化</h2><p>1）更小的通常更好</p><p>2）简单就好</p><p>3）尽量避免NULL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一、整数类型 在存储和计算过程中，int（1）和int（20）是相同的</span><br><span class="line">二、实数类型 mysql支持精确类型，也支持不精确类型</span><br><span class="line">三、字符串类型 varchar 和 char ，varchar是可变长字符串，列更新会有碎片，char是定长的不会有碎片；blob和text，blob是二进制，text是字符方式，memory不支持blob和text；枚举类型</span><br><span class="line">四、日期和时间类型 datetime和timestamp 除特殊行为之外，一般都采用timestamp</span><br><span class="line">五、位数据类型 bit和set</span><br><span class="line">六、选择标识符 </span><br></pre></td></tr></table></figure><p>修改表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较慢的一种，语句需要做多次读和插入操作</span><br><span class="line">alter table sakila.film modify cloumn rental_duration tinyint(3) not null default 5;</span><br><span class="line">比较快的一种</span><br><span class="line">alter table sakila.film alter cloumn rental_duration set default 5;</span><br></pre></td></tr></table></figure><h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><h4 id="1、索引类型"><a href="#1、索引类型" class="headerlink" title="1、索引类型"></a>1、索引类型</h4><table><thead><tr><th>索引</th><th>特点</th><th>缺点</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>通过非叶子节点查询叶子节点获取对应的value，查询效率高</td><td>因为有冗余节点数据，会比较占内存</td></tr><tr><td>哈希索引</td><td>Hash是k,v形式，通过一个散列函数，能够根据key快速找到value；哈希索引就是采用一定的hash算法，把键值换成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需要一次hash算法即可立即定位到相应的位置，速度非常快。</td><td>因为底层数据结构是散列的，无法进行比较大小，不能进行范围查找</td></tr><tr><td>空间数据索引(R-Tree)</td><td>可以用做地理数据存储，会从所有维度来索引数据</td><td>必选使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据，但是mysql的GIS支持不完善</td></tr><tr><td>全文索引</td><td>适用于MATCH AGAINST条件匹配</td><td></td></tr><tr><td>其他索引</td><td></td><td></td></tr></tbody></table><p>B-Tree 索引和哈希索引却别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、如果是等值查询，那么hash索引有明显的优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个键值是唯一的，如果不唯一，则需要先找到下标位置再链式查找。</span><br><span class="line">2、从示意图可以知道，hash索引无法支持范围查询，因为原先是有序的键值，但是经过hash算法后，有可能变成不连续的，就没有办法利用索引完成范围查询检索数据。</span><br><span class="line">3、同样，hash索引也没办法利用索引完成排序，以及like `xxx%`这样的模糊查询（范围查询）。</span><br><span class="line">4、hash索引也不支持多列联合索引的最左前缀匹配规则。</span><br><span class="line">5、B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键的情况下，hash索引的效率也是极低的，因为存在hash碰撞问题</span><br></pre></td></tr></table></figure><p>索引策略</p><p>①独立的列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无法使用索引的</span><br><span class="line">select cloumn from table where cloumn + 1 = 5;</span><br><span class="line">select .... where TO_DAys(CURRENT_DATE) - TO_DAYS(date_col) &lt;= 10;</span><br></pre></td></tr></table></figure><p>②前缀索引和索引选择性</p><p>③多列索引</p><h2 id="五、查询优化"><a href="#五、查询优化" class="headerlink" title="五、查询优化"></a>五、查询优化</h2><p>1）查询不需要的记录</p><p>2）多表关联时返回全部列</p><p>3）总是取出全部列</p><p>4）重复查询相同的数据</p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 数据库SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA Stream流</title>
      <link href="/2022/07/27/JAVA%20Stream%E6%B5%81-20220805/"/>
      <url>/2022/07/27/JAVA%20Stream%E6%B5%81-20220805/</url>
      
        <content type="html"><![CDATA[<h2 id="Stream流简介"><a href="#Stream流简介" class="headerlink" title="Stream流简介"></a>Stream流简介</h2><blockquote><p>Stream（流）是一个来自数据源的元素队列，元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。数据源：流的来源，可以是集合，数组 等。</p></blockquote><h3 id="Stream流的构成"><a href="#Stream流的构成" class="headerlink" title="Stream流的构成"></a>Stream流的构成</h3><h4 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h4><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>stream()</td><td>创建出一个新的stream串行流对象</td></tr><tr><td>parallelStream()</td><td>创建出一个可并行执行的stream流对象</td></tr><tr><td>Stream.of()</td><td>通过给定的一系列元素创建一个新的Stream串行流对象</td></tr></tbody></table><h4 id="对流进行业务操作"><a href="#对流进行业务操作" class="headerlink" title="对流进行业务操作"></a>对流进行业务操作</h4><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>filter()</td><td>按照条件过滤符合要求的元素， 返回新的stream流</td></tr><tr><td>map()</td><td>将已有元素转换为另一个对象类型，一对一逻辑，返回新的stream流</td></tr><tr><td>flatMap()</td><td>将已有元素转换为另一个对象类型，一对多逻辑，即原来一个元素对象可能会转换为1个或者多个新类型的元素，返回新的stream流</td></tr><tr><td>limit()</td><td>仅保留集合前面指定个数的元素，返回新的stream流</td></tr><tr><td>skip()</td><td>跳过集合前面指定个数的元素，返回新的stream流</td></tr><tr><td>concat()</td><td>将两个流的数据合并起来为1个新的流，返回新的stream流</td></tr><tr><td>distinct()</td><td>对Stream中所有元素进行去重，返回新的stream流</td></tr><tr><td>sorted()</td><td>对stream中所有的元素按照指定规则进行排序，返回新的stream流</td></tr><tr><td>peek()</td><td>对stream流中的每个元素进行逐个遍历处理，返回处理后的stream流</td></tr></tbody></table><h4 id="对流进行回收操作"><a href="#对流进行回收操作" class="headerlink" title="对流进行回收操作"></a>对流进行回收操作</h4><table><thead><tr><th>API</th><th>功能说明</th></tr></thead><tbody><tr><td>count()</td><td>返回stream处理后最终的元素个数</td></tr><tr><td>max()</td><td>返回stream处理后的元素最大值</td></tr><tr><td>min()</td><td>返回stream处理后的元素最小值</td></tr><tr><td>findFirst()</td><td>找到第一个符合条件的元素时则终止流处理</td></tr><tr><td>findAny()</td><td>找到任何一个符合条件的元素时则退出流处理，这个对于串行流时与findFirst相同，对于并行流时比较高效，任何分片中找到都会终止后续计算逻辑</td></tr><tr><td>anyMatch()</td><td>返回一个boolean值，类似于isContains(),用于判断是否有符合条件的元素</td></tr><tr><td>allMatch()</td><td>返回一个boolean值，用于判断是否所有元素都符合条件</td></tr><tr><td>noneMatch()</td><td>返回一个boolean值， 用于判断是否所有元素都不符合条件</td></tr><tr><td>collect()</td><td>将流转换为指定的类型，通过Collectors进行指定</td></tr><tr><td>toArray()</td><td>将流转换为数组</td></tr><tr><td>iterator()</td><td>将流转换为Iterator对象</td></tr><tr><td>foreach()</td><td>无返回值，对元素进行逐个遍历，然后执行给定的处理逻辑</td></tr></tbody></table><h3 id="Stream常用"><a href="#Stream常用" class="headerlink" title="Stream常用"></a>Stream常用</h3><h4 id="中间处理"><a href="#中间处理" class="headerlink" title="中间处理"></a>中间处理</h4><h5 id="过滤-filter"><a href="#过滤-filter" class="headerlink" title="过滤(filter)"></a>过滤(filter)</h5>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream = stream.filter(s -&gt; Objects.equals(s.getSex(), <span class="string">&quot;男&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>以上操作表示过滤出所有性别为”男“的学生；</p><p>上述代码等效于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream = stream.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>()&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Student s)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Objects.equals(s.getSex,<span class="string">&quot;男&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>过滤处理可根据需求多次执行</p></blockquote><h4 id="去除重复-distinct"><a href="#去除重复-distinct" class="headerlink" title="去除重复(distinct)"></a>去除重复(distinct)</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream = stream.distinct(); </span><br></pre></td></tr></table></figure><blockquote><p>去除重复元素：依据集合中元素的equals方法和hashcode方法</p></blockquote><h5 id="排序（sorted）"><a href="#排序（sorted）" class="headerlink" title="排序（sorted）"></a>排序（sorted）</h5>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream = stream.sorted((s1,s2) -&gt; (<span class="type">int</span>)(s1.getScore()-s2.getScore()))  </span><br></pre></td></tr></table></figure><blockquote><p>以上操作根据学生的学分从低到高排序</p><p>代码等效于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream = stream.sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1,Student s2)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="type">int</span>)(s1.getScore()-s2.getScore());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>若集合中元素有实现过<code>comparable</code>接口，则可直接使用以下方法时完成排序:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream = stream.sorted()</span><br></pre></td></tr></table></figure></blockquote><h5 id="跳过-skip"><a href="#跳过-skip" class="headerlink" title="跳过(skip)"></a>跳过(skip)</h5>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream = stream.skip(<span class="number">2</span>);<span class="comment">//跳过的数据行数</span></span><br></pre></td></tr></table></figure><h5 id="限制数据行数（limit）"><a href="#限制数据行数（limit）" class="headerlink" title="限制数据行数（limit）"></a>限制数据行数（limit）</h5>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream = stream.limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="结尾处理"><a href="#结尾处理" class="headerlink" title="结尾处理"></a>结尾处理</h4><p>结尾处理即意味着中间处理已完成，等待最终操作，比如收集，统计，迭代等操作。由于结果为最终执行项，因此不可重复调用不同的结尾处理方式，否则会出现异常：</p><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><blockquote><p>以上代码可以使用如下写法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(s-&gt;System.out.println(s));</span><br></pre></td></tr></table></figure></blockquote><h5 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h5>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stream.count();</span><br></pre></td></tr></table></figure><h5 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h5><p>  收集指的是将中间处理之后满足条件的结果存放到集合并返回</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; listStu = stream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h5 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h5><p>对以上Stream的使用可以通过一行代码实现，具体如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = list.stream()<span class="comment">//1.获取流</span></span><br><span class="line">    .filter(s -&gt; Objects.equals(s.getSex(), <span class="string">&quot;男&quot;</span>))  <span class="comment">//2.中间处理  过滤</span></span><br><span class="line">    .filter(s -&gt; s.getScore() &gt;= <span class="number">60</span>) <span class="comment">//2.中间处理 过滤</span></span><br><span class="line">    .distinct() <span class="comment">//2.中间处理 去除重复</span></span><br><span class="line">    .sorted((s1,s2) -&gt; (<span class="type">int</span>)(s1.getScore()-s2.getScore())) <span class="comment">//2.中间处理 排序</span></span><br><span class="line">    .skip(<span class="number">2</span>) <span class="comment">//2.中间处理  跳过</span></span><br><span class="line">    .limit(<span class="number">5</span>) <span class="comment">//2.中间处理  限制结果行数</span></span><br><span class="line">    .map(s-&gt;s.getName()) <span class="comment">//2.中间处理  映射(获取属性子集)</span></span><br><span class="line">    .collect(Collectors.toList());  <span class="comment">//3.结尾处理</span></span><br></pre></td></tr></table></figure><p>后续补充….</p>]]></content>
      
      
      <categories>
          
          <category> 后端必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白菜汤</title>
      <link href="/2022/04/06/%E7%99%BD%E8%8F%9C%E6%B1%A4-20220510/"/>
      <url>/2022/04/06/%E7%99%BD%E8%8F%9C%E6%B1%A4-20220510/</url>
      
        <content type="html"><![CDATA[<p>一个农家的寡妇死掉了她的独子，这个二十岁的青年是全村庄里最好的工人。</p><p>农妇的不幸被地主太太知道了。太太便在那儿子下葬的那一天去探问他的母亲。</p><p>那母亲在家里。</p><p>她站在小屋的中央，在一张桌子前面，伸着右手，不慌不忙地从一只漆黑的锅底舀起稀薄的白菜汤来，一调羹一调羹地吞下肚里去，她的左手无力地垂在腰间。</p><p>她的脸颊很消瘦，颜色也阴暗，眼睛红肿着……然而她的身子却挺得笔直，像在教堂里。</p><p>“呵，天呀！”太太想道，“她在这种时候还吃得下东西！她们这种人真是心肠硬，全都是一样！”这时候太太记起来了，几年前她死掉了九岁的小女儿，她很悲痛，不肯住到彼得堡郊外的别墅去，她宁愿在城里度过整个夏天。然而这个女人却还继续在喝她的白菜汤。</p><p>太太到底忍不住了。“达地安娜，”她说，“啊呀，你真叫我吃惊！难道你真的不喜欢你儿子吗？怎么还有这样好的胃口？怎么还能够喝这白菜汤？”</p><p>“我的瓦西亚死了，”妇人安静地说，悲哀的眼泪又沿着她憔悴的脸颊流下来，“自然我的日子也完了，我活活地给人把心挖了去。然而汤是不该糟蹋的，里面放有盐呢。”</p><p>太太耸了耸肩，走开了。在她看来，盐是不值钱的东西。<br>                                                                         —— 屠格涅夫</p>]]></content>
      
      
      <categories>
          
          <category> 美文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感佳作 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
